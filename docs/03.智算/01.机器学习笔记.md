---
title: 机器学习笔记
date: 2024-11-29 23:15:15
permalink: /tec/mlrecord/
categories:
  - 智算
tags:
  - 
author: 
  name: friedy37
  link: https://github.com/friedy37
---
> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/haopinglianlian/article/details/143917463?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-1-143917463-blog-86524866.235^v43^pc_blog_bottom_relevance_base9&spm=1001.2101.3001.4242.1&utm_relevant_index=4)

![](https://i-blog.csdnimg.cn/direct/0c4ddb985f3a45e89731d8742779eb9e.png)

[机器学习笔记——损失函数、代价函数和 KL 散度](https://blog.csdn.net/haopinglianlian/article/details/143831958?)  
[机器学习笔记——特征工程、正则化、强化学习](https://blog.csdn.net/haopinglianlian/article/details/143832118?)  
[机器学习笔记——30 种常见机器学习算法简要汇总](https://blog.csdn.net/haopinglianlian/article/details/143832321)  
[机器学习笔记——感知机、多层感知机 (MLP)、支持向量机 (SVM)](https://blog.csdn.net/haopinglianlian/article/details/143832552)  
[机器学习笔记——KNN（K-Nearest Neighbors，K 近邻算法）](https://blog.csdn.net/haopinglianlian/article/details/143832692)  
[机器学习笔记——朴素贝叶斯算法](https://blog.csdn.net/haopinglianlian/article/details/143832781?)  
[机器学习笔记——决策树](https://blog.csdn.net/haopinglianlian/article/details/143834363)  
[机器学习笔记——集成学习、Bagging（随机森林）、Boosting（AdaBoost、GBDT、XGBoost、LightGBM）、Stacking](https://blog.csdn.net/haopinglianlian/article/details/143834494?)  
[机器学习笔记——Boosting 中常用算法（GBDT、XGBoost、LightGBM）迭代路径](https://blog.csdn.net/haopinglianlian/article/details/143834628)  
[机器学习笔记——聚类算法（Kmeans、GMM - 使用 EM 优化）](https://blog.csdn.net/haopinglianlian/article/details/143834707)  
[机器学习笔记——降维](https://blog.csdn.net/haopinglianlian/article/details/143834847)

本文用 10w 字总结面试中可能用到的[机器学习](https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020)八股和常用算法，包括感知机（Perceptron）、多层感知机（MLP, Multi-Layer Perceptron）、支持向量机（SVM, Support Vector Machine）、K 最近邻（KNN, K-Nearest Neighbors）、朴素贝叶斯（Naive Bayes）、决策树（Decision Tree）、随机森林（Random Forest）、Bagging、Boosting、GBDT、XGBoos、LightGBM、K 均值聚类（K-means Clustering）、高斯混合模型（GMM）、降维算法。正片开始！！！

![](https://i-blog.csdnimg.cn/direct/b3e2ad89fb7c45ef99f3817ad95b98f8.png)

> #### 文章目录
> 
> *   [损失函数](#_27)
> *   *   [一、回归问题中的损失函数](#_28)
>     *   *   [1. 均方误差（Mean Squared Error, MSE）](#1_Mean_Squared_Error_MSE_29)
>         *   [2. 平均绝对误差（Mean Absolute Error, MAE）](#2_Mean_Absolute_Error_MAE_39)
>         *   [3. 对数余弦损失（Log-Cosh Loss）](#3_LogCosh_Loss_47)
>         *   [4. Huber 损失（Huber Loss）](#4_Huber_Huber_Loss_55)
>         *   [5. 平均平方对数误差（Mean Squared Logarithmic Error, MSLE）](#5_Mean_Squared_Logarithmic_Error_MSLE_63)
>         *   [总结](#_70)
>     *   [二、分类问题中的损失函数](#_80)
>     *   *   [1. 0-1 损失（0-1 Loss）](#1_01_01_Loss_81)
>         *   [2. 对数损失（Log Loss）或交叉熵损失（Cross-Entropy Loss）](#2_Log_LossCrossEntropy_Loss_89)
>         *   [3. Focal 损失（Focal Loss）](#3_Focal_Focal_Loss_97)
>         *   [4. Hinge 损失（合页损失）](#4_Hinge__108)
>         *   [5. Kullback-Leibler 散度（KL Divergence）](#5_KullbackLeibler_KL_Divergence_115)
>         *   [总结](#_123)
> *   [代价函数](#_133)
> *   *   *   [1. 回归问题中的代价函数](#1__136)
>         *   [2. 分类问题中的代价函数](#2__141)
> *   [损失函数和代价函数的选择](#_147)
> *   *   [1. 如何选择适当的损失函数？](#1__148)
>     *   [2. 损失函数和代价函数的优化](#2__159)
> *   [KL 散度](#KL_164)
> *   *   [描述](#_165)
>     *   [KL 散度的特点](#KL_168)
>     *   *   [KL 散度的常见应用场景](#KL_181)
>         *   [1. 变分自编码器（Variational Autoencoder, VAE）中的损失函数](#1_Variational_Autoencoder_VAE_184)
>         *   [2. 分类问题中的交叉熵损失](#2__191)
>         *   [3. 强化学习中的策略优化](#3__197)
>         *   [4. 生成模型中的正则化项](#4__202)
>         *   [5. 多任务学习中的权衡损失](#5__204)
>         *   [6. T-SNE](#6_TSNE_207)
>         *   [总结](#_208)
> *   [特征工程（Fzeature Engineering）](#Fzeature_Engineering_222)
> *   *   [1. 特征提取（Feature Extraction）](#1_Feature_Extraction_223)
>     *   *   [手工特征提取（Manual Feature Extraction）：](#Manual_Feature_Extraction_225)
>         *   [自动特征提取（Automated Feature Extraction）：](#Automated_Feature_Extraction_240)
>     *   [2. 特征选择（Feature Selection）](#2_Feature_Selection_246)
>     *   *   [1. 过滤法（Filter Methods）](#1_Filter_Methods_248)
>         *   [2. 包裹法（Wrapper Methods）](#2_Wrapper_Methods_257)
>         *   [3. 嵌入法（Embedded Methods）](#3_Embedded_Methods_265)
>         *   [4. 其他方法](#4__274)
>         *   [5. 选择方法的应用场景](#5__279)
>         *   [总结](#_284)
>     *   [3. 特征构造（Feature Construction）](#3_Feature_Construction_301)
>     *   [4. 特征缩放](#4__317)
>     *   *   [4.1 归一化（Normalization）](#41_Normalization_322)
>         *   [4.2 标准化（Standardization）](#42_Standardization_328)
>         *   [BN、LN、IN、GN](#BNLNINGN_335)
> *   [正则化](#_340)
> *   [强化学习（Reinforcement Learning）](#Reinforcement_Learning_344)
> *   *   *   [1. Q 学习（Q-Learning）](#1_Q_QLearning_345)
>         *   *   [Q 学习原理](#Q__347)
>             *   [应用场景](#_349)
>             *   [优缺点](#_352)
>         *   [2. 深度 Q 网络（DQN, Deep Q Network）](#2__Q_DQN_Deep_Q_Network_357)
>         *   *   [DQN 原理](#DQN__359)
>             *   [应用场景](#_364)
>             *   [优缺点](#_367)
> *   [常见算法总结](#_373)
> *   *   [监督学习算法（Supervised Learning）](#Supervised_Learning_375)
>     *   *   [回归算法（Regression Algorithms）](#Regression_Algorithms_377)
>         *   [分类算法（Classification Algorithms）](#Classification_Algorithms_385)
>     *   [无监督学习算法（Unsupervised Learning）](#Unsupervised_Learning_410)
>     *   *   [聚类算法（Clustering Algorithms）](#Clustering_Algorithms_411)
>         *   [降维算法（Dimensionality Reduction Algorithms）](#Dimensionality_Reduction_Algorithms_433)
>         *   *   [线性降维算法（Linear Dimensionality Reduction Algorithms）](#Linear_Dimensionality_Reduction_Algorithms_434)
>             *   [非线性降维算法（Nonlinear Dimensionality Reduction Algorithms）](#Nonlinear_Dimensionality_Reduction_Algorithms_447)
>     *   [强化学习算法（Reinforcement Learning）](#Reinforcement_Learning_461)
>     *   [集成学习算法（Ensemble Learning）](#Ensemble_Learning_471)
>     *   [算法详细介绍](#_483)
>     *   *   [1. 监督学习算法（Supervised Learning）](#1_Supervised_Learning_484)
>         *   *   [1.1 回归算法（Regression Algorithms）](#11_Regression_Algorithms_485)
>             *   [1.2 分类算法（Classification Algorithms）](#12_Classification_Algorithms_553)
>         *   [2. 无监督学习算法（Unsupervised Learning）](#2_Unsupervised_Learning_674)
>         *   *   [2.1 聚类算法（Clustering Algorithms）](#21_Clustering_Algorithms_676)
>             *   [2.2 降维算法（Dimensionality Reduction Algorithms）](#22_Dimensionality_Reduction_Algorithms_746)
>         *   [3. 半监督学习算法（Semi-Supervised Learning）](#3_SemiSupervised_Learning_799)
>         *   [4. 强化学习算法（Reinforcement Learning）](#4_Reinforcement_Learning_818)
>         *   [5. 集成学习算法（Ensemble Learning）](#5_Ensemble_Learning_856)
> *   [感知机（Perceptron）](#Perceptron_916)
> *   *   [模型定义](#_920)
>     *   [训练过程](#_935)
>     *   [优势和局限性](#_953)
>     *   [感知机的扩展](#_963)
> *   [多层感知机（MLP, Multilayer Perceptron）](#MLP_Multilayer_Perceptron_969)
> *   *   [定义](#_970)
>     *   [工作原理](#_973)
>     *   [优势和局限性](#_982)
> *   [支持向量机（SVM, Support Vector Machine）](#SVM_Support_Vector_Machine_993)
> *   *   [定义](#_994)
>     *   [工作原理](#_996)
>     *   [核函数（Kernel Function）](#Kernel_Function_1001)
>     *   *   [工作原理](#_1004)
>         *   [类型](#_1015)
>         *   [如何选择](#_1057)
>     *   [软间隔与硬间隔（Soft Margin & Hard Margin）](#Soft_Margin__Hard_Margin_1063)
>     *   [损失函数](#_1077)
>     *   *   [硬间隔 SVM 损失函数](#_SVM__1078)
>         *   [软间隔 SVM 损失函数（Soft Margin SVM）](#_SVM_Soft_Margin_SVM_1098)
>         *   [合页损失（Hinge Loss）](#Hinge_Loss_1120)
>         *   [总结](#_1137)
>     *   [工作流程](#_1146)
>     *   [SVM 多分类](#SVM_1157)
>     *   *   [一对多（One-vs-Rest, OvR）](#OnevsRest_OvR_1159)
>         *   [一对一（One-vs-One, OvO）](#OnevsOne_OvO_1163)
>     *   [优势与局限性](#_1172)
> *   [对比](#_1183)
> *   *   [总结对比](#_1184)
>     *   [基本概念](#_1193)
>     *   [模型结构](#_1202)
>     *   [学习方式和优化](#_1212)
>     *   [适用性和能力](#_1222)
>     *   [优缺点](#_1232)
>     *   [应用场景](#_1242)
> *   [KNN](#KNN_1254)
> *   *   [思想](#_1259)
>     *   [工作原理](#_1262)
>     *   [K 值选择](#K__1269)
>     *   *   [交叉验证](#_1274)
>         *   [类似 K-means 的肘部法](#Kmeans_1280)
>         *   [经验选择法 / 奇数优先](#_1293)
>         *   [加权 KNN](#_KNN_1298)
>     *   [距离度量](#_1305)
>     *   *   [欧氏距离（Euclidean Distance）](#Euclidean_Distance_1306)
>         *   [曼哈顿距离（Manhattan Distance）](#Manhattan_Distance_1318)
>         *   [切比雪夫距离（Chebyshev Distance）](#Chebyshev_Distance_1332)
>         *   [闵可夫斯基距离（Minkowski Distance）](#Minkowski_Distance_1345)
>         *   [余弦相似度（Cosine Similarity）](#Cosine_Similarity_1361)
>     *   [总结](#_1375)
>     *   [维度灾难](#_1395)
>     *   *   [1. 降维技术](#1__1411)
>         *   *   [主成分分析（PCA, Principal Component Analysis）](#PCA_Principal_Component_Analysis_1415)
>             *   [线性判别分析（LDA, Linear Discriminant Analysis）](#LDA_Linear_Discriminant_Analysis_1420)
>             *   [T-SNE（t-Distributed Stochastic Neighbor Embedding）](#TSNEtDistributed_Stochastic_Neighbor_Embedding_1425)
>         *   [2. 特征选择（Feature Selection）](#2_Feature_Selection_1431)
>         *   *   [过滤法（Filter Methods）](#Filter_Methods_1433)
>             *   [包裹法（Wrapper Methods）](#Wrapper_Methods_1437)
>             *   [嵌入法（Embedded Methods）](#Embedded_Methods_1441)
>         *   [3. 使用合适的距离度量](#3__1447)
>         *   *   [马氏距离（Mahalanobis Distance）](#Mahalanobis_Distance_1449)
>             *   [余弦相似度（Cosine Similarity）](#Cosine_Similarity_1475)
>     *   [数据结构来加速最近邻搜索](#_1478)
>     *   *   [KD 树与 Ball 树的比较](#KD__Ball__1479)
>         *   [KD 树（KD-Tree）](#KD_KDTree_1494)
>         *   *   [工作原理](#_1496)
>             *   [特点](#_1500)
>         *   [Ball 树（Ball Tree）](#Ball_Ball_Tree_1503)
>         *   *   [工作原理](#_1505)
>             *   [特点](#_1516)
>     *   [KNN 优缺点](#KNN_1519)
> *   [贝叶斯](#_1538)
> *   *   [贝叶斯定理（Bayes' Theorem）](#Bayes_Theorem_1539)
>     *   [朴素贝叶斯分类器（Naive Bayes Classifier）](#Naive_Bayes_Classifier_1556)
>     *   *   [计算步骤](#_1560)
>         *   [优势](#_1582)
>         *   [局限性](#_1587)
>     *   [朴素贝叶斯的三种常见变体](#_1591)
>     *   *   [1. 高斯朴素贝叶斯（Gaussian Naive Bayes）](#1_Gaussian_Naive_Bayes_1595)
>         *   [2. 多项式朴素贝叶斯（Multinomial Naive Bayes）](#2_Multinomial_Naive_Bayes_1613)
>         *   [3. 伯努利朴素贝叶斯（Bernoulli Naive Bayes）](#3_Bernoulli_Naive_Bayes_1631)
>         *   [总结](#_1648)
>     *   [零概率问题](#_1657)
>     *   *   [总结](#_1669)
>         *   [拉普拉斯平滑（Laplace Smoothing）](#Laplace_Smoothing_1673)
>         *   [加权平滑（Weighted Smoothing）](#Weighted_Smoothing_1684)
>         *   [狄利克雷平滑（Dirichlet Smoothing）](#Dirichlet_Smoothing_1703)
> *   [决策树（Decision Tree）](#Decision_Tree_1720)
> *   *   [决策树（Decision Tree）概述](#Decision_Tree_1722)
>     *   [基本概念](#_1725)
>     *   [任务类型](#_1733)
>     *   *   [分类任务](#_1735)
>         *   [回归任务](#_1747)
>         *   [分类和回归中的差异](#_1757)
>     *   [决策树算法的具体实现](#_1767)
>     *   *   [比较总结](#_1768)
>         *   [ID3（Iterative Dichotomiser 3）](#ID3Iterative_Dichotomiser_3_1781)
>         *   *   [原理](#_1782)
>             *   [主要特点](#_1785)
>             *   [信息熵（Entropy）](#Entropy_1790)
>             *   [信息增益（Information Gain）](#Information_Gain_1801)
>             *   [算法流程](#_1813)
>             *   [优点](#_1818)
>             *   [缺点](#_1821)
>         *   [C4.5](#C45_1825)
>         *   *   [原理](#_1826)
>             *   [主要特点](#_1829)
>             *   [信息增益比（Information Gain Ratio）](#Information_Gain_Ratio_1834)
>             *   [固有信息（Intrinsic Information）](#Intrinsic_Information_1843)
>             *   [处理连续型变量](#_1859)
>             *   [处理缺失值](#_1871)
>             *   [算法流程](#_1880)
>             *   [优点](#_1887)
>             *   [缺点](#_1895)
>         *   [CART（Classification and Regression Tree）](#CARTClassification_and_Regression_Tree_1899)
>         *   *   [原理](#_1900)
>             *   [主要特点](#_1906)
>             *   [分类任务基尼指数（Gini Index）](#Gini_Index_1913)
>             *   [回归任务均方误差（Mean Squared Error, MSE）](#Mean_Squared_Error_MSE_1933)
>             *   [分类树算法流程](#_1942)
>             *   [回归树算法流程](#_1948)
>             *   [优点](#_1960)
>             *   [缺点](#_1965)
>     *   [决策树的过拟合和欠拟合](#_1970)
>     *   *   [解决欠拟合](#_1971)
>         *   [解决过拟合](#_1984)
>     *   [剪枝（Pruning）](#Pruning_1998)
>     *   *   [预剪枝（Pre-pruning）](#Prepruning_2002)
>         *   [后剪枝（Post-pruning）](#Postpruning_2011)
>         *   *   [C4.5 的错误率估计剪枝操作](#C45__2022)
>             *   [CART 的成本复杂度剪枝操作](#CART__2033)
>         *   [总结](#_2049)
> *   [集成学习（Ensemble Learning）概述](#Ensemble_Learning_2059)
> *   *   [Bagging 和 Boosting 的对比](#Bagging__Boosting__2061)
> *   [Bagging 算法](#Bagging__2081)
> *   *   [什么是 Bagging？](#_Bagging_2082)
>     *   [Bagging 的主要特点](#Bagging__2084)
>     *   [常用的 Bagging 算法](#_Bagging__2089)
>     *   *   [随机森林（Random Forest）](#Random_Forest_2090)
> *   [Boosting 算法](#Boosting__2098)
> *   *   [什么是 Boosting？](#_Boosting_2099)
>     *   [Boosting 的主要特点](#Boosting__2101)
>     *   [常用的 Boosting 算法](#_Boosting__2105)
>     *   *   [AdaBoost（Adaptive Boosting）](#AdaBoostAdaptive_Boosting_2121)
>         *   [GB（Gradient Boosting）](#GBGradient_Boosting_2136)
>         *   [GBDT（Gradient Boosting Decision Tree）](#GBDTGradient_Boosting_Decision_Tree_2158)
>         *   *   [GB 和 GBDT 的关系](#GBGBDT_2175)
>             *   [损失函数](#_2181)
>             *   *   [回归问题](#_2183)
>                 *   [分类问题](#_2188)
>         *   [XGBoost（Extreme Gradient Boosting）](#XGBoostExtreme_Gradient_Boosting_2192)
>         *   *   [1. 目标函数及正则化项](#1__2207)
>             *   *   [损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​)](#_Ly_i_haty_i_2215)
>                 *   [正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​)](#_Omegaf_m_2221)
>             *   [2. 二阶导数优化](#2__2239)
>             *   [3. 分裂增益计算](#3__2252)
>             *   *   [分裂增益和 ID3 的信息增益的区别](#ID3_2267)
>             *   [4. 并行化](#4__2286)
>         *   [LightGBM（Light Gradient Boosting Machine）](#LightGBMLight_Gradient_Boosting_Machine_2292)
>         *   *   [直方分裂算法（Histogram-based Splitting）](#Histogrambased_Splitting_2312)
>             *   [基于叶子生长的策略（Leaf-wise Growth Strategy）](#Leafwise_Growth_Strategy_2341)
>     *   [GBDT、XGBoost、LightGBM 迭代路径](#GBDTXGBoostLightGBM_2368)
> *   [Stacking 算法](#Stacking__2373)
> *   *   [基本思想和流程](#_2377)
>     *   [实现步骤](#_2384)
>     *   *   [步骤 1：选择基学习器和元学习器](#_1_2385)
>         *   [步骤 2：准备第一层输入数据（K 折交叉验证）](#_2K__2389)
>         *   [步骤 3：训练元学习器](#_3_2401)
>         *   [步骤 4：生成最终预测](#_4_2405)
>     *   [优点和缺点](#_2408)
>     *   *   [优点](#_2409)
>         *   [缺点](#_2414)
>     *   [变体](#_2418)
>     *   [实际实现中的注意事项](#_2430)
>     *   [总结](#_2438)
> *   [XGBoost 相对 GBDT 的改进](#XGBoost__GBDT__2445)
> *   *   [引入正则化项，防止过拟合](#_2460)
>     *   *   [损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​)](#_Ly_i_haty_i_2467)
>         *   [正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​)](#_Omegaf_m_2473)
>     *   [使用二阶导数信息，加速收敛](#_2487)
>     *   *   [一阶导数与二阶导数的区别](#_2497)
>         *   [二阶导数的优势](#_2501)
>         *   *   [1. 更准确的步长选择，避免过大或过小的更新](#1__2506)
>             *   [2. 更快速的收敛](#2__2514)
>             *   [3. 更稳定的模型优化](#3__2519)
>     *   [支持列采样和行采样，提升模型的泛化能力](#_2525)
>     *   *   [行采样（Row Subsampling）](#Row_Subsampling_2535)
>         *   [列采样（Column Subsampling）](#Column_Subsampling_2543)
>         *   [行采样与列采样的结合](#_2554)
>         *   [优势总结](#_2557)
>     *   [并行化处理，提升训练速度](#_2561)
>     *   *   [结合特征分片与直方分裂的并行化优势](#_2567)
>         *   [LightGBM 和 XGBoost 中直方分裂的差异](#LightGBM__XGBoost__2571)
>     *   [支持缺失值处理和稀疏特征优化](#_2578)
>     *   [提供早停机制和学习率衰减，控制训练过程](#_2584)
> *   [LightGBM 相较于 XGBoost 的优势](#LightGBM__XGBoost__2590)
> *   *   [训练速度](#_2593)
>     *   *   [内存效率](#_2608)
>     *   [类别特征支持](#_2620)
>     *   [扩展性和分布式训练支持](#_2631)
>     *   [早停机制和自动调参](#_2644)
>     *   [过拟合控制](#_2656)
>     *   *   [总结](#_2668)
> *   [聚类](#_2687)
> *   *   [K-Means](#KMeans_2688)
>     *   *   [工作原理](#_2690)
>         *   [特点](#_2695)
>     *   [K-Medoids](#KMedoids_2699)
>     *   *   [工作原理](#_2701)
>         *   [特点](#_2711)
>     *   [Mini-Batch K-Means](#MiniBatch_KMeans_2714)
>     *   *   [工作原理](#_2716)
>         *   [特点](#_2722)
>     *   [K-Means++（重要）](#KMeans_2725)
>     *   *   [工作原理](#_2727)
>         *   [特点](#_2732)
>     *   [总结](#_2735)
>     *   [K 的选值](#K_2741)
>     *   *   [1. 肘部法则（Elbow Method）](#1_Elbow_Method_2743)
>         *   [2. 平均轮廓系数（Silhouette Score）](#2_Silhouette_Score_2756)
>         *   [3. Gap Statistic（间隙统计量）](#3_Gap_Statistic_2769)
>         *   [4. Davies-Bouldin 指数](#4_DaviesBouldin__2783)
>         *   [5. 信息准则（如 BIC/AIC）](#5__BICAIC_2795)
>         *   [总结](#_2807)
>     *   [高斯混合模型（GMM, Gaussian Mixture Model）](#GMM_Gaussian_Mixture_Model_2816)
>     *   *   [公式](#_2818)
>         *   [优势](#_2828)
>     *   [EM 算法（Expectation-Maximization Algorithm）](#EMExpectationMaximization_Algorithm_2832)
>     *   *   [使用 EM 训练 GMM（进行参数估计）](#EMGMM_2834)
>         *   *   [EM 算法的步骤](#EM_2835)
>         *   [EM 算法的特点](#EM_2906)
>         *   [GMM 和 EM 的关系](#GMM__EM__2911)
>     *   [GMM 与 K-Means 的比较](#GMM__KMeans__2917)
>     *   [其他聚类算法](#_2927)
>     *   *   [层次聚类（Hierarchical Clustering）](#Hierarchical_Clustering_2928)
>         *   *   [1. 凝聚式层次聚类（Agglomerative Hierarchical Clustering）](#1_Agglomerative_Hierarchical_Clustering_2932)
>             *   [2. 分裂式层次聚类（Divisive Hierarchical Clustering）](#2_Divisive_Hierarchical_Clustering_2947)
>             *   [优缺点](#_2956)
>         *   [DBSCAN（Density-Based Spatial Clustering of Applications with Noise）](#DBSCANDensityBased_Spatial_Clustering_of_Applications_with_Noise_2962)
>         *   *   [核心概念](#_2966)
>             *   [参数](#_2972)
>             *   [工作流程](#_2976)
>             *   [特点](#_2987)
>             *   [优缺点](#_2992)
>             *   [参数选择](#_3002)
> *   [降维方法概述](#_3009)
> *   [线性降维方法](#_3013)
> *   *   [定义](#_3015)
>     *   [特点](#_3018)
>     *   [常见方法](#_3024)
>     *   *   [PCA（Principal Component Analysis，主成分分析）](#PCAPrincipal_Component_Analysis_3025)
>         *   *   [原理](#_3026)
>             *   [步骤](#_3028)
>             *   [降维后的数据](#_3034)
>             *   [优点](#_3046)
>             *   [缺点](#_3050)
>             *   [应用场景](#_3055)
>         *   [LDA（Linear Discriminant Analysis，线性判别分析）](#LDALinear_Discriminant_Analysis_3061)
>         *   *   [原理](#_3062)
>             *   [步骤](#_3065)
>             *   [降维后的数据](#_3089)
>             *   [优点](#_3103)
>             *   [缺点](#_3107)
>             *   [应用场景](#_3116)
>         *   [SVD（Singular Value Decomposition，奇异值分解）——LORA 使用](#SVDSingular_Value_DecompositionLORA_3121)
>         *   *   [原理](#_3122)
>             *   [步骤](#_3131)
>             *   [降维后的数据](#_3152)
>             *   [各矩阵含义](#_3167)
>             *   [优点](#_3174)
>             *   [缺点](#_3177)
>             *   [应用场景](#_3181)
>         *   [比较总结](#_3185)
> *   [非线性降维方法](#_3200)
> *   *   [总结：不同核方法的核函数选择策略](#_3201)
>     *   [定义](#_3213)
>     *   [特点](#_3215)
>     *   [常见方法](#_3220)
>     *   *   [Kernel PCA（核主成分分析, Kernel Principal Component Analysis）](#Kernel_PCA_Kernel_Principal_Component_Analysis_3221)
>         *   *   [原理](#_3222)
>             *   [步骤](#_3224)
>             *   [优点](#_3226)
>             *   [缺点](#_3229)
>             *   [应用场景](#_3232)
>         *   [NDA（Nonlinear Discriminant Analysis，非线性判别分析）](#NDANonlinear_Discriminant_Analysis_3236)
>         *   *   [原理](#_3237)
>             *   [步骤](#_3239)
>             *   [优点：](#_3242)
>             *   [缺点](#_3245)
>             *   [应用场景](#_3248)
>         *   [T-SNE（t-Distributed Stochastic Neighbor Embedding，t 分布随机邻域嵌入）](#TSNEtDistributed_Stochastic_Neighbor_Embeddingt__3252)
>         *   *   [原理](#_3253)
>             *   [步骤](#_3257)
>             *   [优点](#_3275)
>             *   [缺点](#_3279)
>             *   [应用场景](#_3284)
>             *   [Autoencoder（自编码器）](#Autoencoder_3287)
>             *   [原理](#_3288)
>             *   [结构](#_3293)
>             *   [优点](#_3300)
>             *   [缺点](#_3304)
>             *   [应用场景](#_3309)
>         *   [对比总结](#_3314)
> *   [总结](#_3329)

在机器学习中，**损失函数**和**代价函数**是评估[模型性能](https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&spm=1001.2101.3001.7020)的重要工具。

*   **损失函数衡量单个样本**的预测值与真实值之间的差异。
*   **代价函数则是所有样本**的损失的平均值或总和，用于衡量模型在**整个数据集上**的表现。

不同的任务和模型选择不同的[损失函数](https://so.csdn.net/so/search?q=%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)和代价函数，以反映其特定的优化目标。

损失函数
----

### 一、回归问题中的损失函数

#### 1. 均方误差（Mean Squared Error, MSE）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/94e69af6cf5a4d9784b81a3055f7350a.png)

*   **描述**：MSE 衡量的是预测值和真实值之间的**平方误差的平均值**。对较大的误差会进行更大的惩罚，因此它对异常值（outliers）非常敏感。
*   **应用场景**：线性回归、岭回归等模型的损失函数。
*   **优点**：简单易于理解，容易求导和计算。
*   **缺点**：**对异常值敏感**，可能导致模型被少数异常样本主导。

#### 2. 平均绝对误差（Mean Absolute Error, MAE）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/0a1a2a30e7ef40fcadba32418f63e315.png)

*   **描述**：MAE 衡量的是预测值和真实值之间的**绝对误差的平均值**。它对每个误差的惩罚是线性的，因此对异常值的惩罚不如 MSE 严重。
*   **应用场景**：在对异常值不敏感的回归任务中使用。
*   **优点**：**对异常值不敏感**，能够更加稳定地反映模型性能。
*   **缺点**：在优化过程中，**绝对值函数不可导**，求解困难。

#### 3. 对数余弦损失（Log-Cosh Loss）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/b48bddd7f65147649a39729d215a6677.png)

*   **描述**：对数余弦损失是 **Huber 损失的变体**，它的行为类似于 MAE，同时对大误差有更小的增长率。
*   **应用场景**：适用于异常值影响较大的回归任务。
*   **优点**：具有**平滑性，易于求导**，**对小误差敏感**而**对大误差鲁棒**。
*   **缺点**：相比其他损失函数计算复杂度较高。

#### 4. Huber 损失（Huber Loss）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/8d6eef62dbc7403c93e732428de2c112.png)

*   **描述**：Huber 损失是 **MSE 和 MAE 的折中**。对于**小误差，使用 MSE**；对于**大误差，使用 MAE**，从而对异常值有一定的鲁棒性。
*   **应用场景**：回归问题中存在异常值，但又不希望过于忽略异常值的场景。
*   **优点**：**对小误差敏感**，同时**对大误差具有一定的抗干扰性**。
*   **缺点**：参数 ( δ \delta δ) 需要手动调节，不同数据集效果不同。

#### 5. 平均平方对数误差（Mean Squared Logarithmic Error, MSLE）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/886f75fde7fc4f6a84a743a4116168b4.png)

*   **描述**：MSLE 用于处理**目标值差异较大**且**有显著指数增长趋势**的情况。它**更关注相对误差**，而非绝对误差。
*   **应用场景**：如人口增长预测、市场销量预测等场景。
*   **优点**：对**大数值的预测更稳定**，对目标值的比例关系有更好的衡量。
*   **缺点**：当目标值非常小时，惩罚效果不明显。

#### 总结

<table><thead><tr><th><strong>损失函数</strong></th><th><strong>描述</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>均方误差 (MSE)</strong></td><td>衡量预测值和真实值之间<strong>平方误差的平均值</strong>，对较大误差进行更大惩罚。</td><td>线性回归、岭回归等</td><td>简单易于理解，容易求导。</td><td><strong>对异常值敏感</strong>。</td></tr><tr><td><strong>平均绝对误差 (MAE)</strong></td><td>衡量预测值和真实值之间<strong>绝对误差的平均值</strong>。</td><td>对异常值不敏感的回归任务</td><td><strong>对异常值不敏感</strong>，反映模型性能更稳定。</td><td>优化困难，<strong>绝对值函数不可导</strong>。</td></tr><tr><td><strong>对数余弦损失 (Log-Cosh)</strong></td><td>Huber 损失的变体，既<strong>能捕捉小误差，也对大误差有更小的增长率</strong>。</td><td>异常值影响较大的回归任务</td><td>平滑性好，<strong>易于求导</strong>，适应大误差和小误差。</td><td>计算复杂度高。</td></tr><tr><td><strong>Huber 损失 (Huber Loss)</strong></td><td><strong>结合 MSE 和 MAE</strong>，小误差时使用 MSE，大误差时使用 MAE，平衡异常值的影响。</td><td>存在异常值但不希望完全忽略的场景</td><td>对小误差敏感，对大误差有抗干扰性。</td><td>需调节参数 (delta)。</td></tr><tr><td><strong>平均平方对数误差 (MSLE)</strong></td><td>衡量目标值差异大且有<strong>指数增长</strong>趋势的情况，<strong>关注相对误差</strong>而非绝对误差。</td><td>人口增长预测、市场销量预测等</td><td>对大数值预测更稳定，<strong>适应有比例关系的数据</strong>。</td><td>对极小值目标效果不佳。</td></tr></tbody></table>

### 二、分类问题中的损失函数

#### 1. 0-1 损失（0-1 Loss）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/cdeefaaf27d7449eb7159d951ccafc96.png)

*   **描述**：0-1 损失表示**分类是否正确**，**0 为正确分类，1 为错误分类**。它无法直接用于模型优化，只能用于评价模型性能。
*   **应用场景**：模型性能的评估，如准确率（Accuracy）的计算。
*   **优点**：简单直观，能够清晰判断分类是否正确。
*   **缺点**：**不可导，无法用于梯度优化**。

#### 2. 对数损失（Log Loss）或交叉熵损失（Cross-Entropy Loss）

![](https://i-blog.csdnimg.cn/direct/f000311087304082a398b46420a636cd.png)

*   **描述**：交叉熵损失衡量的是**预测分布和真实分布之间的距离**。在**二分类与 Sigmoid 函数结合**；在**多分类与 Softmax 函数结合**。
*   **应用场景**：广泛用于逻辑回归、神经网络等分类任务。
*   **优点**：能够很好地度量概率分布之间的差异，梯度计算简单。
*   **缺点**：**对数据不平衡较为敏感**。

> ![](https://i-blog.csdnimg.cn/direct/d1795d25af664bb4a3b630cf6a10b382.png)  
> ![](https://i-blog.csdnimg.cn/direct/510e7a3a49a843cb88a37fb2dbcfc279.png)

#### 3. Focal 损失（Focal Loss）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/f08a3e8d03054c95aa186cf735d6dc8f.png)

> 注：t 是该样本的真实类别标签  
> ![](https://i-blog.csdnimg.cn/direct/cc4a010d11814f119d53edf49aa2efe6.png)

*   **描述**：Focal 损失是对**交叉熵损失的改进**，用于**解决类别不平衡问题**。通过调节参数 ( γ \gamma γ ) 和 ( α \alpha α )，它**增加了对困难样本的关注**，降低了对易分类样本的影响。
*   **应用场景**：目标检测中的单阶段检测器（如 RetinaNet），以及其他类别不平衡的分类问题。
*   **优点**：有效**解决类别不平衡问题**，增强模型对困难样本的关注。
*   **缺点**：参数选择复杂，训练时间较长。

#### 4. Hinge 损失（合页损失）

![](https://i-blog.csdnimg.cn/direct/a2e6a86d2f1d4772acb703d2e260218d.png)

*   **描述**：Hinge 损失用于**支持向量机（SVM）**中。它在样本被**正确分类且间隔大于 1 时，损失为 0**；否则损失为 1。旨在最大化样本的分类间隔。
*   **应用场景**：线性支持向量机、核支持向量机等。
*   **优点**：有助于**最大化分类间隔**，提高模型的泛化能力。
*   **缺点**：对于误差大的样本损失增长过快。

#### 5. Kullback-Leibler 散度（KL Divergence）

**定义**：  
![](https://i-blog.csdnimg.cn/direct/77d132646ee34c5a884bc265ef2dd3dc.png)

*   **描述**：KL 散度**衡量两个概率分布之间的差异**，常用于**无监督学习中的聚类分析**。
*   **应用场景**：概率模型的优化，如变分自编码器（VAE）、生成对抗网络（GAN）中的判别模型。
*   **优点**：对概率分布之间的**微小差异非常敏感**。
*   **缺点**：对**稀疏分布**的概率模型**不稳定**。

#### 总结

<table><thead><tr><th><strong>损失函数</strong></th><th><strong>描述</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>0-1 损失 (0-1 Loss)</strong></td><td>分类正确为 0，错误为 1，用于衡量分类是否正确。</td><td>准确率等分类性能评估</td><td>简单直观。</td><td><strong>不可导，无法用于优化</strong>。</td></tr><tr><td><strong>交叉熵损失 (Cross-Entropy)</strong></td><td>衡量预测分布和真实分布之间的距离，二分类结合 Sigmoid，多分类结合 Softmax。</td><td>逻辑回归、神经网络等分类任务</td><td>很好地衡量概率分布差异，梯度计算简单。</td><td><strong>对数据不平衡敏感</strong>。</td></tr><tr><td><strong>Focal 损失 (Focal Loss)</strong></td><td>交叉熵的改进，通过调节 (gamma) 和 ( alpha )，增加对困难样本的关注，减少易分类样本影响，解决类别不平衡问题。</td><td>类别不平衡问题，如目标检测 (RetinaNet)</td><td>增强对困难样本的关注，<strong>解决类别不平衡</strong>。</td><td>参数选择复杂，训练时间较长。</td></tr><tr><td><strong>Hinge 损失 (合页损失)</strong></td><td>用于 SVM，正确分类且间隔大于 1 时损失为 0，旨在最大化分类间隔。</td><td><strong>线性 SVM、核 SVM</strong></td><td>提高泛化能力，有助于<strong>最大化分类间隔</strong>。</td><td>对误差大的样本损失增长快。</td></tr><tr><td><strong>KL 散度 (KL Divergence)</strong></td><td><strong>衡量两个概率分布的差异</strong>，常用于<strong>无监督学习中的聚类</strong>分析。</td><td>概率模型优化，如 VAE、GAN</td><td>对<strong>概率分布的差异敏感</strong>。</td><td>对<strong>稀疏分布不稳定</strong>。</td></tr></tbody></table>

[代价函数](https://so.csdn.net/so/search?q=%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)
----------------------------------------------------------------------------------------------------

代价函数是损失函数在**整个训练集上的平均或总和**，用于衡量**模型在整个数据集上的表现**。

> 代价函数 = 所有样本的损失函数的平均值或总和。因此，代价函数通常是通过对每个样本的损失函数进行求和或求平均得到的。

#### 1. 回归问题中的代价函数

**均方误差代价函数（Cost Function for MSE）**：  
![](https://i-blog.csdnimg.cn/direct/48e6089134ae43f6ac926bc2ef021b33.png)

*   **描述**：均方误差代价函数用于衡量模型预测值与真实值之间的总体误差。
*   **应用场景**：线性回归、岭回归等回归任务。

#### 2. 分类问题中的代价函数

**对数损失代价函数（Cost Function for Log Loss）**：  
![](https://i-blog.csdnimg.cn/direct/4a27b6405ad14d16a03372d3d662b3aa.png)

*   **描述**：对数损失代价函数用于二分类任务，衡量模型预测概率与真实分布之间的差异。
*   **应用场景**：逻辑回归、神经网络的二分类问题。

损失函数和代价函数的选择
------------

### 1. 如何选择适当的损失函数？

*   **回归问题**：
    *   数据中**存在异常值**时，可以选择 **MAE** 或 **Huber 损失**。
    *   如果**异常值较少**、**误差分布相对均匀**，【对大误差容忍度低时】可以选择 **MSE**。
    *   数据有显著的**指数增长趋势**时，选择 **MSLE**。

> MAE 和 Huber 损失**减少异常值对损失和模型的过度影响**，所以适合存在较多异常值的情况。它们的目标是在存在异常值的情况下，保持模型对大多数数据的稳定性和准确性。

*   **分类问题**：
    *   二分类问题：常用 **交叉熵损失**。
    *   多分类问题：使用 **Softmax + 交叉熵损失**。
    *   类别不平衡时：选择 **Focal 损失**。

### 2. 损失函数和代价函数的优化

*   **梯度下降法**：用于**最小化代价函数**，找到模型参数的最优解。
*   **正则化**：在代价函数中加入正则化项（L1 或 L2）防止模型过拟合。

总结来说，损失函数和代价函数是机器学习模型优化的核心工具，选择合适的损失函数能够帮助模型更好地学习数据的特性，并提高模型的性能和鲁棒性。

KL 散度
-----

### 描述

KL 散度是一种用于**衡量两个概率分布之间差异的度量**。在信息论中，它也称为**相对熵**，用于表达当我们用分布 ( Q Q Q ) 来近似真实分布 ( P P P ) 时，所损失的信息量。  
![](https://i-blog.csdnimg.cn/direct/5b162aae69af417f8a45fde6d592d9a2.png)

### KL 散度的特点

KL 散度的三个性质：非负性、非对称性和无界性。

1.  **非负性**：  
    KL 散度始终非负，( D K L ( P ∥ Q ) ≥ 0 D_{KL}(P \parallel Q) \geq 0 DKL​(P∥Q)≥0 )，并且仅当 ( P = Q P = Q P=Q ) 时，KL 散度为 0。这意味着两个分布越相似，KL 散度越小。当两个分布完全相同时，KL 散度为零，即没有信息损失。
    
2.  **非对称性**：  
    KL 散度不是对称的，( D K L ( P ∥ Q ) ≠ D K L ( Q ∥ P D_{KL}(P \parallel Q) \neq D_{KL}(Q \parallel P DKL​(P∥Q)=DKL​(Q∥P) )，因此它并不是一个真正的距离度量。KL 散度衡量的是使用分布 ( Q Q Q ) 来近似分布 ( P P P ) 的信息损失，因此方向性很重要，交换两个分布后，信息损失会不同。
    
3.  **无界性**：  
    KL 散度可以趋向无穷大，特别是在 ( Q (i) = 0 Q(i) = 0 Q(i)=0 ) 且 ( P (i) > 0 P(i) > 0 P(i)>0 ) 的情况下。因为 ( log ⁡ (0) \log(0) log(0) ) 趋于负无穷，这意味着如果 ( Q Q Q ) 对某个事件的概率估计为零，而 ( P P P ) 认为这个事件是可能的，那么使用 ( Q Q Q ) 来近似 ( P P P ) 的信息损失会非常大，导致 KL 散度无限大。
    

#### KL 散度的常见应用场景

**KL 散度**常在**处理概率分布的模型中作为损失函数的一部分**。通过在损失函数中加入 KL 散度，模型可以在多个任务中有效地优化**预测分布与真实分布之间的差异**。以下是 KL 散度作为损失函数一部分的几种常见应用：

#### 1. 变分自编码器（Variational Autoencoder, VAE）中的损失函数

在 VAE 中，损失函数包含两部分：

*   **重构误差**：衡量重建的**输出和输入数据的差异**（通常是均方误差或二元交叉熵）。
*   **KL 散度**：衡量潜在变量的**后验分布**与**先验分布（通常是标准正态分布）** 之间的**差异**。  
    ![](https://i-blog.csdnimg.cn/direct/0d5b50f8937a46c0abe48fe2877da0a5.png)  
    KL 散度项确保潜在空间的分布接近于标准正态分布，从而提高生成数据的连续性和多样性。

#### 2. 分类问题中的交叉熵损失

分类问题中的交叉熵损失实际上可以看作是 KL 散度的一种形式。在分类问题中，真实标签通常表示为 one-hot 向量，模型输出的则是一个预测概率分布。最小化交叉熵损失就是最小化真实分布和预测分布之间的 KL 散度。  
![](https://i-blog.csdnimg.cn/direct/0adf06db949d4c9884862e349f2ee0f3.png)

由于真实分布 (P) 是 one-hot 形式，所以 H( P ) 是常数，最小化交叉熵损失等价于最小化 KL 散度。

#### 3. [强化学习](https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&spm=1001.2101.3001.7020)中的策略优化

在强化学习中，KL 散度可以**作为策略更新中的约束**，**确保新策略 (π’) 和旧策略 ( π ) 不偏离太远**。这种方法通过将 KL 散度作为损失函数的一部分进行优化，以确保策略的平稳更新。

在这种情况下，目标是通过最小化以下损失函数进行策略更新：  
![](https://i-blog.csdnimg.cn/direct/f0d14825d85c4bc48fe3f2560e6a2100.png)

#### 4. 生成模型中的正则化项

KL 散度也常用于生成对抗网络（GAN）和其他生成模型中的正则化项。通过引入 KL 散度，模型可以保持生成分布与某个目标分布的接近度。这通常用于引导生成样本的多样性和稳定性。

#### 5. 多任务学习中的权衡损失

在某些多任务学习场景中，KL 散度可以用来衡量某一任务的输出分布与其他任务输出分布的差异，从而引入额外的正则化约束，以便各任务在共享网络中的学习互不冲突。

#### 6. T-SNE

#### 总结

KL 散度是一种广泛应用于机器学习和深度学习中的度量工具，尤其是在涉及**概率分布的场景**中。其主要用于**衡量模型预测的分布与真实分布的差异**，并通过最小化 KL 散度来优化模型表现。具体应用场景包括：

*   变分自编码器中的潜在分布优化
*   分类任务中的交叉熵损失
*   强化学习中的策略更新约束
*   生成模型中的分布正则化

通过将 KL 散度引入损失函数，模型可以在复杂任务中更好地平衡生成质量、分布匹配以及策略优化的需求。

![](https://i-blog.csdnimg.cn/direct/9e1cf5acb24545acb59825d0b5b965d2.png)

特征工程（Fzeature Engineering）
--------------------------

### 1. 特征提取（Feature Extraction）

**特征提取**：从**原始数据**中**提取**能够有效表征**数据特征**的过程。它将原始数据转换为适合模型输入的特征表示。

#### 手工特征提取（Manual Feature Extraction）：

*   **文本数据**：
    *   **词袋模型**（Bag of Words）：将文本数据转化为**词频向量**，每个单词是一个维度，值为该单词在文本中出现的次数。
    *   **TF-IDF**：为词袋模型加入**词频 - 逆文档频率**（Term Frequency-Inverse Document Frequency），**降低常见词语的权重**，**提升重要词语的权重**。
    *   **N-gram**：将连续的 N 个词作为一个特征，捕捉**词语间的局部依赖关系**。
    *   > 具体参考此文第一部分： [万字长文解读深度学习——循环神经网络 RNN、LSTM、GRU、Bi-RNN](https://lichuachua.blog.csdn.net/article/details/142679758)
        
*   **图像数据**：
    *   **边缘检测**：使用 Sobel 算子、Canny 边缘检测等方法提取图像边缘信息。
    *   **SIFT（尺度不变特征变换）**：提取图像的关键点和局部特征，具有尺度不变性和旋转不变性。
    *   **HOG（方向梯度直方图）**：将图像分块，并统计每块的梯度方向直方图，用于描述局部形状和纹理特征。
*   **时间序列数据**：
    *   **移动平均**：对时间序列进行平滑，消除短期波动。
    *   **傅里叶变换**：将时间域的信号转化为频域信号，分析数据的周期性。
    *   **窗口函数**：将时间序列分为若干窗口，分别计算每个窗口的统计特征，如均值、方差等。

#### 自动特征提取（Automated Feature Extraction）：

*   使用**卷积神经网络（CNN）**：从图像中自动提取高级特征，如边缘、纹理、形状等。
*   使用**循环神经网络（RNN）**：处理时间序列数据，捕捉长时间依赖关系。
*   使用 **BERT（Transformer）**：通过自监督学习自动提取上下文敏感的文本特征。
*   **自动编码器（Autoencoder）**：使用无监督学习从数据中提取低维特征表示，捕捉数据的潜在结构和模式。

### 2. 特征选择（Feature Selection）

特征选择（Feature Selection）是指**从原始特征集中挑选出与目标任务最相关的特征**，以提高模型的性能、减少训练时间以及降低过拟合的风险。特征选择方法主要分为三类：**过滤法（Filter Methods）**、**包裹法（Wrapper Methods）** 和 **嵌入法（Embedded Methods）**。

#### 1. 过滤法（Filter Methods）

*   **原理**：独立于模型，**训练前**首先根据某些**统计指标对特征进行评分**，然后选择得分较高的特征。这种方法不依赖于特定的学习算法，只是**基于数据本身的特性进行筛选**。
*   **常见方法**：
    *   **方差选择法**：**剔除方差较小的特征**，认为方差小的特征对目标值影响小。
    *   **皮尔森相关系数**：计算特征与目标变量之间的线性相关性，**选择线性相关性较高的特征**。
    *   **互信息**：衡量特征与目标变量之间的**信息增益**，选择信息量大的特征。
*   **优点**：**计算效率高，易于实现**。
*   **缺点**：未考虑特征之间的相互作用，可能遗漏组合特征的重要性。

#### 2. 包裹法（Wrapper Methods）

*   **原理**：在**训练中**，通过训练模型**评估特征子集的表现**，使用搜索策略找到对目标任务最优的**特征组合**。包裹法直接**根据模型的性能进行选择**，通常**通过交叉验证**来评估特征子集的好坏。
*   **常见方法**：
    *   **前向选择（Forward Selection）**：从**空集开始**，**逐步添加**对模型性能提升最大的特征。
    *   **后向消除（Backward Elimination）**：从**所有特征开始**，**逐步移除**对模型性能影响最小的特征。
*   **优点**：能够**考虑特征之间的相互作用**，适合复杂的特征选择任务。
*   **缺点**：计算开销大，尤其是当特征数目较多时，训练多个模型的过程会非常耗时。

#### 3. 嵌入法（Embedded Methods）

*   **原理**：嵌入法**结合了过滤法和包裹法**的优点，直接**在模型训练过程**中**自动选择特征**。它通过学习算法自动选择最重要的特征，使特征选择与模型训练同时进行。
*   **常见方法**：
    *   **L1 正则化（Lasso 回归）**：通过在损失函数中**添加 L1 正则化项**，使 ** 部分特征的系数变为零，从而进行特征选择。
    *   **决策树及其变体（如随机森林、XGBoost）**：树模型的特征重要性得分可以用于选择重要特征。
    *   **Elastic Net**：结合 L1 和 L2 正则化的优势，在保持模型稀疏性的同时，减少了多重共线性的影响，进行特征选择和模型优化。
*   **优点**：特征选择与模型训练同时完成，考虑特征间的相互作用，效率较高。
*   **缺点**：需要根据特定算法来进行选择，不具有模型无关性。

#### 4. 其他方法

*   **PCA（主成分分析）**：虽然 PCA 是降维方法，但在某些场景下可以间接用于特征选择。通过对数据进行线性变换，将多个原始特征组合成少数几个主成分。
*   **LDA（线性判别分析）**：常用于分类问题的降维，也可以视作一种特征选择方法。
*   **基于稳定性选择（Stability Selection）**：通过在多次子样本集上重复训练模型，并选择那些在多个子集上都表现重要的特征，从而增强选择的鲁棒性。

#### 5. 选择方法的应用场景

*   **过滤法**适用于快速预筛选大量特征的情况，计算效率高，但可能丢失特征之间的组合信息。
*   **包裹法**在特征数不多时（例如几十个或上百个）效果较好，能找到最佳的特征组合，但计算开销较大。
*   **嵌入法**通常适用于大多数场景，尤其是使用线性模型（Lasso）或树模型时，既能训练模型又能自动选择特征。

#### 总结

下面是特征选择方法的总结表格，保留了原有的描述信息：

<table><thead><tr><th><strong>方法类别</strong></th><th><strong>原理</strong></th><th><strong>常见方法</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>过滤法（Filter Methods）</strong></td><td>独立于模型，基于统计指标对特征评分，并选择得分较高的特征。</td><td>- 方差选择法：剔除方差较小的特征<br>- 皮尔森相关系数：选择线性相关性高的特征<br>- 互信息：选择信息增益大的特征</td><td>计算效率高，易于实现</td><td>未考虑特征间相互作用，可能遗漏重要的组合特征</td><td>快速预筛选大量特征的情况，适合初步筛选特征</td></tr><tr><td><strong>包裹法（Wrapper Methods）</strong></td><td>通过训练模型评估特征子集表现，使用搜索策略找到最优特征组合。</td><td>- 递归特征消除（RFE）：删除不重要的特征<br>- 前向选择：逐步添加性能提升最大的特征<br>- 后向消除：逐步移除对模型性能影响小的特征</td><td>能考虑特征间的相互作用，适合复杂任务</td><td>计算开销大，训练多个模型耗时长</td><td>特征数较少（几十到上百个），适合需要精确特征选择的任务</td></tr><tr><td><strong>嵌入法（Embedded Methods）</strong></td><td>结合过滤法和包裹法的优点，在模型训练过程中选择特征。</td><td>- L1 正则化（Lasso 回归）：通过 L1 正则化项使部分特征系数为零<br>- 决策树及其变体（随机森林、XGBoost）：根据特征重要性评分选择特征<br>- Elastic Net：结合 L1 和 L2 正则化</td><td>特征选择与模型训练同时进行，考虑特征间相互作用，效率高</td><td>需要根据特定算法选择，不具有模型无关性</td><td>适合使用线性模型（如 Lasso）或树模型的场景，大多数现代复杂模型都适用</td></tr><tr><td><strong>其他方法</strong></td><td>PCA、LDA 等方法虽然是降维方法，但可间接用于特征选择。</td><td>- PCA：通过线性变换将多个特征组合成少数几个主成分<br>- LDA：常用于分类问题的降维方法<br>- 稳定性选择（Stability Selection）：通过在子样本集上选择表现稳定的特征</td><td>能够进行有效降维，有时可以间接用于特征选择</td><td>降维后特征解释性较弱</td><td>数据维度较高的情况下，可以用作降维手段，间接提高特征选择效果</td></tr></tbody></table>

*   **过滤法**：速度快，适合**预处理**大量特征，但可能丢失特征间的组合信息。
*   **包裹法**：精度高，适合特征数较少且精度要求高的任务，但计算成本大。
*   **嵌入法**：**性能和效率兼顾，适合大多数场景，尤其是使用线性模型（Lasso）或树模型时**。
*   **其他方法**：如 PCA、LDA 等可以作为降维手段，间接用于特征选择，适合高维数据的场景。

选择合适的特征选择方法能够有效提升模型性能，降低训练时间，避免过拟合。

### 3. 特征构造（Feature Construction）

**特征构造**是通过**对已有特征进行组合、变换或生成新特征**来增强模型表达能力的过程。它可以将隐含的关系显式化，提高模型的拟合能力。

<table><thead><tr><th>类别</th><th>主要方法</th><th>适用场景</th></tr></thead><tbody><tr><td>数值特征构造</td><td>变换、分箱</td><td>处理数值特征、非线性关系</td></tr><tr><td>类别特征构造</td><td>编码、组合</td><td>处理类别特征、捕捉特征间关系</td></tr><tr><td>时间特征构造</td><td>时间提取、周期特征、时间差</td><td>时间序列数据、周期性特征</td></tr><tr><td>文本特征构造</td><td>词袋、TF-IDF、词向量、N-grams</td><td>文本数据、自然语言处理</td></tr><tr><td>特征交互与组合</td><td>特征交互、多项式特征</td><td>捕捉特征间的复杂关系，适合增强线性模型的非线性拟合能力</td></tr><tr><td>聚合与统计特征</td><td>聚合、统计、窗口聚合</td><td>大规模表格数据、时间序列数据</td></tr><tr><td>生成模型特征</td><td>降维、聚类、自编码器生成特征</td><td>复杂高维数据、需要特征压缩的场景</td></tr><tr><td>特征选择与构造结合</td><td>筛选后构造、嵌入法生成特征</td><td>大规模数据集、特征选择与构造结合的场景</td></tr></tbody></table>

特征构造是一项创造性和技术性并重的任务，需要结合领域知识、数据分析技巧以及机器学习经验来挖掘出更有利于模型训练的特征，从而提升模型的表现。

### 4. 特征缩放

1.  **归一化**：通常是指将数据**缩放到一个特定的范围，如 [0, 1]**。目的是**让不同特征的值处于相同的尺度上**，【同时也有消除不同特征量纲的影响的作用】**大范围的特征值可能会导致梯度更新过慢或不稳定**。
2.  **标准化**：是指对数据进行**均值 0、标准差 1** 的变换，**更关注数据的分布形态**。目的是**消除不同特征的物理单位和量纲（如重量、温度、距离等）差异**，同时保持特征间的相对比例关系。

#### 4.1 归一化（Normalization）

**归一化**将**特征值缩放到 [0, 1] 之间**，常用于以下算法中：

*   **K 近邻算法（KNN）**：归一化后减少**不同特征尺度对距离计算的影响**。能够避免特征量纲不同带来的距离计算问题。【与数据的分布无关】
*   **神经网络**：将输入特征值缩放至 [0, 1]，有助于加快模型收敛。
*   **聚类算法（如 K-Means）**：归一化避免特征尺度不同造成聚类结果偏差。  
    ![](https://i-blog.csdnimg.cn/direct/5763c2701f3744809244cc889055041f.png)

#### 4.2 标准化（Standardization）

**标准化**将**特征值转化为均值为 0、方差为 1 的标准正态分布**，常用于以下算法中：

*   **线性回归**：标准化能够提升参数解释性，并避免部分特征影响过大。
*   **逻辑回归**：标准化能够使梯度下降更快地收敛。
*   **支持向量机（SVM）**：标准化后距离计算更稳定。
*   **主成分分析（PCA）**：标准化防止某些方差大的特征主导主成分的计算。  
    ![](https://i-blog.csdnimg.cn/direct/cd0db0e82937455cae8ee62da83ac260.png)

#### BN、LN、IN、GN

> 参考：[深度学习——优化算法、激活函数、归一化、正则化](https://lichuachua.blog.csdn.net/article/details/142665273)

**注意：** 虽然它们方法名字中带 “归一化”（批归一化、层归一化、实例归一化、组归一化），但它们的核心操作本质上是标准化，将多个输入特征**归一化为均值为 0、方差为 1 的分布**，使得网络的各层输入保持在较为稳定的范围内。本质上是进行标准化。再进行引入两个可学习参数 γ 和 𝛽，分别表示缩放和平移操作。

正则化
---

参考第四部分：[深度学习——优化算法、激活函数、归一化、正则化  
](https://lichuachua.blog.csdn.net/article/details/142665273)

强化学习（Reinforcement Learning）
----------------------------

#### 1. Q 学习（Q-Learning）

**Q 学习**是一种**基于值函数的强化学习算法**，用于**在离散状态和动作空间中学习最优策略**。它通过**更新 Q 值表来估计状态 - 动作对的价值，从而指导智能体在环境中的行为**。

##### Q 学习原理

![](https://i-blog.csdnimg.cn/direct/240a74404fc5483eb2f29bac8994ec6f.png)

##### 应用场景

*   **离散状态和动作空间的决策问题**：如迷宫导航、棋类游戏、路径规划等。
*   **资源管理**：在云计算、通信网络中分配资源。

##### 优缺点

*   **优点**：无需环境模型，能够在部分可观

测环境中学习最优策略。

*   **缺点**：高维状态空间下需要大量存储，训练时间长。

#### 2. 深度 Q 网络（DQN, Deep Q Network）

**DQN** 是结合深度学习和 Q 学习的一种算法，使用神经网络逼近 Q 值函数，能够在高维状态空间中学习有效策略。

##### DQN 原理

*   **Q 值逼近**：用神经网络代替传统 Q 学习中的 Q 表，网络输入状态 (s)，输出各个动作的 Q 值。
*   **经验回放（Experience Replay）**：将智能体的经验存储到回放池中，训练时从中随机抽取小批量经验，打破样本间相关性，提升训练稳定性。
*   **目标网络（Target Network）**：引入目标网络来计算 Q 值更新中的目标值，减少训练过程中的不稳定性。

##### 应用场景

*   **高维状态空间的决策问题**：如 Atari 游戏、无人驾驶、自动驾驶等。
*   **复杂策略学习**：如复杂的游戏 AI、智能交通控制等。

##### 优缺点

*   **优点**：能够处理高维状态空间和复杂策略问题，拓展了 Q 学习的应用范围。
*   **缺点**：训练不稳定，对超参数敏感，训练时间长。

![](https://i-blog.csdnimg.cn/direct/d59e06650c6b4d75b619595614d1978f.png)

常见算法总结
------

### 监督学习算法（Supervised Learning）

#### 回归算法（Regression Algorithms）

*   线性回归（Linear Regression）
*   岭回归（Ridge Regression）
*   套索回归（Lasso Regression）
*   决策树（Decision Tree）
*   随机森林（Random Forest）
*   梯度提升树（Gradient Boosting, GB）
*   XGBoost 和 LightGBM

#### 分类算法（Classification Algorithms）

*   逻辑回归（Logistic Regression）
*   k 近邻算法（K-Nearest Neighbors, KNN）
*   支持向量机（Support Vector Machine, SVM）
*   朴素贝叶斯（Naive Bayes）
*   决策树（Decision Tree）
*   随机森林（Random Forest）
*   梯度提升树（Gradient Boosting, GB）
*   XGBoost 和 LightGBM

**总结：**

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>线性回归</strong></td><td>预测<strong>连续数值型变量的算法</strong>。它通过拟合一条直线，来表示自变量与因变量之间的线性关系，预测连续变量。</td><td>房价预测、股票价格预测。</td><td>简单易用，结果易解释，适合小规模数据。</td><td>只能处理线性关系，对异常值敏感。</td></tr><tr><td><strong>岭回归</strong></td><td>在<strong>损失函数中加入 L2 正则化</strong>，防止过拟合。</td><td>多重共线性问题的数据集。</td><td><strong>防止过拟合，处理多重共线性问题</strong>。</td><td>不能进行特征选择，所有特征系数减小。</td></tr><tr><td><strong>套索回归</strong></td><td>在<strong>损失函数中加入 L1 正则化</strong>，自动进行特征选择。</td><td>高维数据的特征选择和回归预测。</td><td><strong>自动特征选择，产生稀疏解</strong>。</td><td>特征高度相关时，模型不稳定。</td></tr><tr><td><strong>逻辑回归</strong></td><td>用于二分类任务的线性分类模型，是一种<strong>分类算法</strong>。通过<strong> sigmoid 函数</strong>将线性组合转为概率，用于分类。</td><td>垃圾邮件检测、疾病诊断等<strong>二分类任务</strong>。</td><td>简单高效，概率输出易理解，适合高维稀疏数据。</td><td>只能处理线性可分问题，对离群点敏感。</td></tr><tr><td><strong>KNN</strong></td><td>根据<strong>样本的 K 个邻居</strong>的类别决定待分类样本的类别。</td><td>文本分类、图像识别等。</td><td>实现简单、易于理解，<strong>无需训练</strong>，对异常值不敏感。</td><td><strong>计算复杂度高</strong>，容易受噪声和高维数据影响。</td></tr><tr><td><strong>SVM</strong></td><td>寻找<strong>最大化类间间隔的超平面</strong>进行分类。</td><td>图像分类、文本分类、生物信息学。</td><td>在<strong>高维空间表现良好</strong>，泛化能力强，<strong>可处理非线性问题</strong>。</td><td>训练时间长，<strong>对参数和核函数敏感</strong>。</td></tr><tr><td><strong>朴素贝叶斯</strong></td><td>基于贝叶斯定理，<strong>假设特征间相互独立</strong>，通过<strong>先验</strong>和<strong>条件概率</strong>进行<strong>分类</strong>。</td><td>文本分类、垃圾邮件检测等。</td><td>训练和预测速度快，对小规模数据表现良好。</td><td>特征独立性假设不常成立，类别分布不均衡时效果差。</td></tr><tr><td><strong>决策树</strong></td><td>通过<strong>递归分割特征空间</strong>构建决策树模型<strong>进行分类或回归</strong>。</td><td>客户分类、信用评分。</td><td>直观易懂，能处理数值和类别型特征。</td><td><strong>容易过拟合</strong>，对数据变动敏感。</td></tr><tr><td><strong>随机森林</strong></td><td>Bagging 集成学习的一种，<strong>对数据集进行有放回的随机采样</strong>并且<strong>随机选择特征</strong>，通过<strong>两个随机</strong>，<strong>组合多个决策树</strong>提高预测性能（数据集随机和特征随机）。</td><td><strong>分类和回归任务</strong>，适合大数据场景。</td><td><strong>稳定性高</strong>，能处理高维数据和噪声。</td><td>计算复杂度高，预测速度慢。 <strong>用来解决过拟合（高方差（High Variance）），易欠拟合</strong></td></tr><tr><td><strong>梯度提升树</strong></td><td>通过逐步<strong>构建多个弱学习器，逐步降低误差</strong>。</td><td>广泛应用于广告预测、信用评分等。</td><td><strong>捕捉复杂特征关系，精度高</strong>。</td><td>训练速度慢，<strong>用来解决欠拟合（高偏差（High Bias）），易过拟合</strong>。</td></tr><tr><td><strong>XGBoost/LightGBM</strong></td><td>梯度提升的优化版本，采用<strong>高效的数据结构</strong> 和 <strong>算法优化策略</strong> ，支持 <strong>并行计算</strong>，并能够处理大规模数据。</td><td>大规模分类和回归任务，如广告预测、推荐系统等。</td><td>训练速度快，支持并行计算，防止过拟合。</td><td>参数多，调参复杂，解释性较差。</td></tr></tbody></table>

### 无监督学习算法（Unsupervised Learning）

#### 聚类算法（Clustering Algorithms）

*   K-Means 聚类
*   K-Medoids
*   Mini-Batch K-Means
*   K-Means++
*   层次聚类（Hierarchical Clustering）
*   高斯混合模型（Gaussian Mixture Model, GMM）
*   DBSCAN（Density-Based Spatial Clustering of Applications with Noise）

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>K-Means 聚类</strong></td><td><strong>基于质心</strong>，将数据分为 K 个簇，通过<strong>最小化样本到质心的距离</strong>进行聚类。</td><td>市场细分、图像分割、社交网络社区发现。</td><td>算法简单、计算速度快，适合均匀分布数据。</td><td><strong>对噪声和初始质心敏感</strong>，需要指定簇的数量 K。</td></tr><tr><td><strong>K-Means++</strong></td><td>通过优化初始质心选择（从<strong>数据集中随机选择</strong>一个样本点以及选择<strong>距离现有质心最远的点</strong>作为下一个质心），<strong>减少随机初始化的影响</strong>，提高聚类效果。</td><td>K-Means 的优化版本，适合初始质心选择较难的场景。</td><td>提高了初始质心选择的合理性，减少收敛到局部最优解的可能性。</td><td>仍然需要指定 K 值，且对噪声数据敏感。</td></tr><tr><td><strong>K-Medoids</strong></td><td>基于<strong>样本的代表点</strong>而非质心进行聚类，使用<strong>最靠近簇中心的样本作为代表点</strong>，<strong>减少异常值的影响</strong>。</td><td>偏好用样本代表而非质心的场景，适用于异常值多的数据。</td><td>更鲁棒于异常值和噪声，避免极端值影响聚类结果。</td><td>计算复杂度高，比 K-Means 慢，不适合大规模数据。</td></tr><tr><td><strong>Mini-Batch K-Means</strong></td><td>K-Means 的扩展版本，<strong>每次只使用数据子集</strong>进行更新，适合大规模数据集的聚类。</td><td>大规模数据聚类，如在线广告分类、图像分类等。</td><td>计算速度快，适合大数据场景，能够处理流式数据。</td><td>可能不如标准 K-Means 精确，结果依赖于批次的选择。</td></tr><tr><td><strong>层次聚类</strong></td><td>基于相似性构建层次结构，通过<strong>合并或拆分样本形成树状结构</strong>进行聚类。</td><td>基因表达数据分析、图像处理、文本分类。</td><td>无需提前指定 K 值，层次结构便于理解。</td><td>计算复杂度高，对噪声数据敏感，难以处理大规模数据。</td></tr><tr><td><strong>高斯混合模型（GMM）</strong></td><td><strong>假设数据由多个高斯分布混合而成</strong>，使用<strong> EM 算法</strong>估计参数，通过概率分配进行软聚类。</td><td>聚类、密度估计、异常检测。</td><td>能<strong>处理复杂簇形状</strong>，提供软聚类结果。</td><td>对初始参数敏感，计算复杂度高，不适合大规模数据。</td></tr><tr><td><strong>DBSCAN</strong></td><td>基于密度的聚类算法，通过定义核心点和边界点发现簇，能够识别噪声数据。</td><td>空间数据挖掘、图像处理、地理信息系统。</td><td>能发现任意形状的簇，对噪声和异常值鲁棒。</td><td>对参数（ε和 MinPts）敏感，数据密度差异大时效果差。</td></tr></tbody></table>

#### 降维算法（Dimensionality Reduction Algorithms）

##### 线性降维算法（Linear Dimensionality Reduction Algorithms）

*   主成分分析（PCA, Principal Component Analysis）
*   线性判别分析（LDA, Linear Discriminant Analysis）
*   奇异值分解（SVD）

**总结：**

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>主成分分析（PCA）</strong></td><td>通过<strong>线性变换</strong>将<strong>高维数据投影到低维空间</strong>，保持<strong>投影方向上的方差最大化</strong>，进行<strong>无监督的降维方法</strong>。</td><td>数据可视化、噪声消除、特征提取，如图像处理、金融数据分析。</td><td>算法简单，计算高效，保留主要信息。</td><td>仅能捕捉线性关系，无法处理非线性数据。</td></tr><tr><td><strong>线性判别分析（LDA）</strong></td><td>通过<strong>最大化类间方差</strong>与<strong>最小化类内方差</strong>，找到有助于分类的投影方向，进行<strong>有监督的降维</strong>。</td><td>有标签数据的降维和分类任务，如人脸识别、文本分类。</td><td>结合分类信息进行降维，有助于分类。</td><td>仅适用于线性可分的数据，对多类别不平衡问题效果不佳。</td></tr><tr><td><strong>奇异值分解（SVD）</strong></td><td>将原始数据矩阵<strong>分解为特征向量和特征值</strong>的矩阵形式，能够<strong>保留数据的主要特征</strong>，常用于<strong>矩阵降维</strong>。</td><td>文本分析、协同过滤推荐系统、图像压缩。</td><td>能有效处理稀疏数据、维度较高的数据，适合矩阵数据。</td><td>对大规模数据计算复杂度较高，不适合处理非线性数据。</td></tr></tbody></table>

##### 非线性降维算法（Nonlinear Dimensionality Reduction Algorithms）

*   核主成分分析（K-PCA）
*   核判别分析（NDA）
*   T-SNE

**总结：**

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>T-SNE</strong></td><td>通过在<strong>高维</strong>和<strong>低维</strong>空间中分别<strong>计算点对之间的相似度</strong>，然后<strong>最小化两个分布之间的差异</strong> ，使相似数据点在低维空间中靠近。</td><td><strong>高维数据的可视化和降维</strong>，如图像数据、文本数据。</td><td>保持数据的局部结构，适合数据可视化。</td><td>计算复杂度高，对参数敏感，结果不稳定。</td></tr><tr><td><strong>核主成分分析（K-PCA）</strong></td><td>在 PCA 的基础上引入<strong>核技巧</strong>，通过<strong>核函数</strong>将数据映射到高维空间，<strong>然后使用 PCA</strong> 在高维空间进行线性降维。</td><td><strong>非线性数据的降维</strong>，如图像分类、非线性回归。</td><td>能处理非线性数据，适用于高维复杂数据集。</td><td>核函数的选择对结果影响较大，计算开销较高。</td></tr><tr><td><strong>核判别分析（NDA）</strong></td><td><strong>核函数</strong>扩展的线性判别分析，利用非线性映射将数据投影到高维空间，<strong>再使用 NDA</strong>，进行分类任务的降维。</td><td><strong>非线性分类问题</strong>，如复杂图像分类、模式识别。</td><td>能处理非线性分类任务，保持类间和类内方差的平衡。</td><td>需要选择合适的核函数，计算复杂度高。</td></tr></tbody></table>

### 强化学习算法（Reinforcement Learning）

*   Q 学习（Q-Learning）
*   深度 Q 网络（DQN, Deep Q Network）

**总结：**

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>Q 学习</strong></td><td>基于<strong>值函数</strong>的强化学习算法，通过<strong>状态 - 动作对</strong>的评分指导行为，<strong>逼近最优策略</strong>。</td><td>离散状态和动作空间的任务，如迷宫导航、棋类游戏。</td><td><strong>无需模型信息</strong>，通过与环境交互学习最优策略。</td><td>高维状态空间需要大量内存，收敛慢。</td></tr><tr><td><strong>深度 Q 网络（DQN）</strong></td><td><strong>结合深度学习</strong>和强化学习，通过<strong>神经网络</strong>逼近 Q 值，处理<strong>高维状态空间</strong>。</td><td>高维状态空间任务，如视频游戏、无人驾驶。</td><td>能处理高维状态空间，学习复杂策略。</td><td>训练不稳定，依赖于经验回放和目标网络，超参数敏感。</td></tr></tbody></table>

### 集成学习算法（Ensemble Learning）

*   袋装法（Bagging）
*   提升法（Boosting）
*   堆叠法（Stacking）

**总结：**

<table><thead><tr><th><strong>算法</strong></th><th><strong>解释</strong></th><th><strong>应用场景</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>袋装法（Bagging）</strong></td><td>通过对进行多次<strong>数据集有放回的随机采样</strong> ，训练多个模型。</td><td>** 随机森林就是其中一种，** 不稳定模型（如决策树、神经网络）的分类和回归任务。</td><td>有效降低方差，提高模型稳定性，对噪声鲁棒。</td><td>训练多个模型，计算复杂度高。</td></tr><tr><td><strong>提升法（Boosting）</strong></td><td><strong>串行</strong>，通过逐步<strong>训练一系列弱模型</strong>，每个模型都试图<strong>纠正前一个模型的错误预测</strong></td><td>分类和回归任务，如广告点击率预测、信用评分。</td><td>有效降低偏差，提升模型精度，适合处理复杂的非线性关系。</td><td>训练时间长，易过拟合，对异常值敏感。</td></tr><tr><td><strong>堆叠法（Stacking）</strong></td><td>通过训练多个<strong>基模型</strong>，将其预测结果作为新特征，进一步训练一个<strong>元模型</strong>，提升整体预测性能。</td><td>适合传统单模型效果不佳的分类和回归任务。</td><td>综合多个模型的优势，提升模型表现，灵活性强。</td><td>计算复杂度高，易过拟合，调参难度大。</td></tr></tbody></table>

### 算法详细介绍

#### 1. 监督学习算法（Supervised Learning）

##### 1.1 回归算法（Regression Algorithms）

**1. 线性回归（Linear Regression）**

*   **解释**：  
    线性回归是一种用于预测连续数值型变量的算法。它通过拟合一条直线（在多维空间中是一个超平面），来表示自变量（特征）与因变量（目标值）之间的线性关系。模型的目标是最小化预测值与真实值之间的均方误差（MSE）。
    
*   **应用场景**：
    
    *   房价预测、股票价格预测等连续数值型变量的预测任务。
    *   分析两个或多个变量之间的线性关系。
*   **优点**：
    
    *   简单易用，结果易于解释。
    *   计算速度快，适合小规模数据集和初步数据分析。
*   **缺点**：
    
    *   只能处理线性关系，无法处理非线性数据。
    *   对异常值敏感，容易受噪声影响。

**2. 岭回归（Ridge Regression）**

*   **解释**：  
    岭回归是线性回归的扩展版本，通过在损失函数中加入 L2 正则化项来限制模型的复杂度，防止过拟合问题。它对模型的系数进行约束，使得所有特征的权重都较小。
    
*   **应用场景**：
    
    *   数据量大、特征数量多的回归问题。
    *   存在多重共线性（特征间高度相关）的问题。
*   **优点**：
    
    *   通过 L2 正则化减少模型复杂度，防止过拟合。
    *   能有效处理特征之间的多重共线性问题。
*   **缺点**：
    
    *   可能导致所有特征系数减小，但不会进行特征选择。

**3. 套索回归（Lasso Regression）**

*   **解释**：  
    套索回归也是线性回归的一种变体，它在损失函数中加入 L1 正则化项，可以通过惩罚不重要的特征使其权重变为零，从而自动进行特征选择。
    
*   **应用场景**：
    
    *   高维数据场景中进行特征选择和回归预测。
    *   需要识别重要特征的场景，如基因数据分析。
*   **优点**：
    
    *   通过 L1 正则化自动选择特征，产生稀疏解。
    *   能够将不重要的特征权重缩减为 0，有助于模型解释性。
*   **缺点**：
    
    *   当特征高度相关时，模型会随机选择其中一个特征，导致不稳定。

**4. 逻辑回归（Logistic Regression）**

*   **解释**：  
    逻辑回归是一种用于二分类任务的线性分类模型，尽管名称中包含 “回归”，但它实际上是一种分类算法。它通过 sigmoid 函数将线性组合转换为概率，并根据概率值来决定样本的类别。
    
*   **应用场景**：
    
    *   二分类任务，如垃圾邮件检测、疾病诊断、信用评分等。
    *   多分类任务可以使用 Softmax 回归扩展。
*   **优点**：
    
    *   简单、高效，概率输出便于理解和解释。
    *   适合高维稀疏数据，且可以通过正则化防止过拟合。
*   **缺点**：
    
    *   只能处理线性可分问题，无法处理复杂的非线性关系。
    *   对离群点敏感，模型效果依赖于特征工程。

##### 1.2 分类算法（Classification Algorithms）

**5. k 近邻算法（K-Nearest Neighbors, KNN）**

*   **解释**：  
    KNN 是一种基于实例的学习方法，通过测量待分类样本与训练集中样本的距离，将最近的 K 个样本的类别作为参考，以简单投票或加权投票的方式决定待分类样本的类别。
    
*   **应用场景**：
    
    *   文本分类、图像识别、推荐系统等。
    *   数据分布较为简单、类别之间有明显距离的分类任务。
*   **优点**：
    
    *   实现简单、易于理解，无需训练过程。
    *   对异常值不敏感，适合小规模数据。
*   **缺点**：
    
    *   计算复杂度高，随着数据量增加，预测速度变慢。
    *   对噪声和高维数据敏感，容易受距离度量方式影响。

**6. 支持向量机（Support Vector Machine, SVM）**

*   **解释**：  
    SVM 是一种强大的二分类算法，它通过寻找最大化类间间隔的超平面来进行分类。SVM 可以通过引入核函数将数据从低维空间映射到高维空间，从而能够处理非线性分类问题。
    
*   **应用场景**：
    
    *   图像分类、文本分类、生物信息学等二分类问题。
    *   特征维度高、样本数量较小的场景，如人脸识别、基因表达数据分类。
*   **优点**：
    
    *   在高维空间中表现良好，泛化能力强。
    *   可以通过核函数处理非线性问题。
*   **缺点**：
    
    *   训练时间长，计算复杂度高，尤其是在大规模数据上。
    *   对参数和核函数选择敏感，调优复杂。

**7. 朴素贝叶斯（Naive Bayes）**

*   **解释**：  
    朴素贝叶斯是一种基于贝叶斯定理的概率分类算法，假设特征之间相互独立。它通过计算每个类别的先验概率和特征条件概率，得出样本属于每个类别的后验概率，从而进行分类。
    
*   **应用场景**：
    
    *   文本分类、垃圾邮件检测、情感分析等 NLP 任务。
    *   数据量小且特征间独立性较强的分类问题。
*   **优点**：
    
    *   训练和预测速度快，对小规模数据表现良好。
    *   对特征间相互独立假设的场景有很好的表现。
*   **缺点**：
    
    *   假设特征相互独立，实际应用中常不成立。
    *   对数据量较少、类别分布不均衡的数据效果较差。

**8. 决策树（Decision Tree）**

*   **解释**：  
    决策树是一种树状的模型，它将样本的特征空间递归地分割为互斥的子空间，每个分割对应一个决策节点。最终形成的树形结构用于预测新样本的类别或数值。
    
*   **应用场景**：
    
    *   客户分类、信用评分、风险评估等。
    *   对数据分布不均衡、特征与目标变量关系复杂的场景。
*   **优点**：
    
    *   直观易懂，结果解释性强。
    *   既能处理数值型特征，也能处理类别型特征。
*   **缺点**：
    
    *   容易过拟合，泛化能力差。
    *   对数据中的微小变动敏感，模型不稳定。

**9. 随机森林（Random Forest）**

*   **解释**：  
    随机森林是集成学习中的一种，它通过组合多个决策树模型来提高预测性能。每棵树使用从样本数据中随机抽样的数据和随机选择的特征进行训练，最终通过所有树的投票结果进行预测。
    
*   **应用场景**：
    
    *   分类和回归任务，广泛应用于金融、医疗、营销等领域。
    *   数据量大、特征多样且存在噪声的场景。
*   **优点**：
    
    *   通过集成多棵决策树，模型稳定性高，防止过拟合。
    *   能处理缺失数据和高维数据。
*   **缺点**：
    
    *   计算复杂度高，预测速度慢。
    *   不容易解释，对特征重要性计算较难。

**10. 梯度提升树（Gradient Boosting, GB）**

*   **解释**：  
    梯度提升树是一种提升（Boosting）算法，通过逐步构建多个弱学习器（决策树），每个学习器在前一个学习器的基础上进行改进，逐步降低训练误差。它的目标是最小化损失函数。
    
*   **应用场景**：
    
    *   各种分类和回归任务，如广告点击率预测、信用评分、风险控制等。
    *   需要高准确率的任务，如 Kaggle 比赛。
*   **优点**：
    
    *   能够捕捉复杂的特征关系，精度高。
    *   提供灵活的损失函数，适应不同的任务需求。
*   **缺点**：
    
    *   训练速度慢，对参数设置敏感。
    *   易过拟合，尤其在数据量少时。

**11. XGBoost 和 LightGBM**

*   **解释**：  
    XGBoost 和 LightGBM 是基于梯度提升的优化版本，旨在提高训练速度和模型性能。它们采用高效的数据结构和算法优化策略，支持并行计算，并能够处理大规模数据。
    
*   **应用场景**：
    
    *   大规模数据的分类和回归问题，如信用风险评估、客户流失预测。
    *   高维数据场景，如广告预测、推荐系统等。
*   **优点**：
    
    *   计算速度快，适合大数据集，支持并行计算。
    *   提供了多种正则化和剪枝策略，防止过拟合。
*   **缺点**：
    
    *   参数较多，调参复杂。
    *   解释性相对较差，模型黑箱性强。

#### 2. 无监督学习算法（Unsupervised Learning）

##### 2.1 聚类算法（Clustering Algorithms）

**12. K-Means 聚类**

*   **解释**：  
    K-Means 聚类是一种基于质心的无监督学习算法，它通过将数据分成 K 个簇，每个簇由一个质心表示。算法通过反复迭代，最小化样本到其最近质心的距离平方和，从而将样本分配到相应的簇。
    
*   **应用场景**：
    
    *   市场细分、图像分割、社交网络社区发现等。
    *   数据量大且簇分布均匀的场景。
*   **优点**：
    
    *   算法简单、计算速度快，易于理解和实现。
    *   对球形簇和均匀分布数据效果较好。
*   **缺点**：
    
    *   需要提前指定簇的数量 K。
    *   对噪声和异常值敏感，容易受初始中心影响。

**13. 层次聚类（Hierarchical Clustering）**

*   **解释**：  
    层次聚类是一种基于数据之间的相似性逐步构建层次结构的算法。它通过将样本逐步合并（自底向上）或逐步拆分（自顶向下），形成一个聚类的树状结构（树状图）。
    
*   **应用场景**：
    
    *   基因表达数据分析、图像处理、文本分类等。
    *   数据量小且不确定 K 值时使用。
*   **优点**：
    
    *   无需提前指定簇的数量，层次结构便于理解。
    *   可以生成聚类的树状结构，观察不同层次的聚类结果。
*   **缺点**：
    
    *   计算复杂度高，数据量大时效率低。
    *   对噪声数据敏感，且难以处理大规模数据。

**14. 高斯混合模型（Gaussian Mixture Model, GMM）**

*   **解释**：  
    高斯混合模型是一种基于概率密度估计的聚类算法，它假设数据是由多个高斯分布混合而成的。每个高斯分布表示一个簇，算法通过期望最大化（EM）算法来估计模型参数，从而将数据点分配到不同的簇。
    
*   **应用场景**：
    
    *   聚类、密度估计、异常检测、图像分割等。
    *   数据分布复杂、有重叠的场景。
*   **优点**：
    
    *   能处理复杂的簇形状和大小差异较大的簇。
    *   提供软聚类结果，每个数据点属于各个簇的概率。
*   **缺点**：
    
    *   对初始参数敏感，可能收敛到局部最优解。
    *   计算复杂度高，不适合大数据场景。

**15. DBSCAN（Density-Based Spatial Clustering of Applications with Noise）**

*   **解释**：  
    DBSCAN 是一种基于密度的聚类算法，通过将密度相连的样本归为同一个簇，并能够识别噪声数据。它定义了核心点、边界点和噪声点，通过 ε 邻域和最小点数来确定簇的结构。
    
*   **应用场景**：
    
    *   空间数据挖掘、图像处理、地理信息系统等。
    *   数据分布不规则、噪声数据较多的场景。
*   **优点**：
    
    *   能发现任意形状的簇，能够自动确定簇的数量。
    *   对噪声数据和异常值鲁棒性强。
*   **缺点**：
    
    *   对参数（如 ε 和 MinPts）敏感，不同数据集需手动调参。
    *   在数据密度差异较大时，效果较差。

##### 2.2 降维算法（Dimensionality Reduction Algorithms）

**16. 主成分分析（PCA, Principal Component Analysis）**

*   **解释**：  
    PCA 是一种降维算法，通过将高维数据线性变换到低维空间中，同时保持数据在投影方向上的方差最大化。它找到新的正交基，将数据投影到主成分上，从而减少特征维度。
    
*   **应用场景**：
    
    *   数据可视化、噪声消除、特征提取等。
    *   高维数据降维，如图像处理、金融数据分析。
*   **优点**：
    
    *   计算简单，易于实现和解释。
    *   能有效减少特征维度，保留数据主要信息。
*   **缺点**：
    
    *   仅能捕捉线性关系，无法处理非线性数据。
    *   对数据中心化要求严格，离群点会影响效果。

**17. 线性判别分析（LDA, Linear Discriminant Analysis）**

*   **解释**：  
    LDA 是一种同时考虑降维和分类的线性模型。它通过最大化类间方差和最小化类内方差的比值，找到最有利于分类的低维子空间投影方向。它适用于有标签数据的降维和分类。
    
*   **应用场景**：
    
    *   降维和分类结合的场景，如人脸识别、文本分类等。
    *   需要最大化类别间差异、最小化类别内差异的降维任务。
*   **优点**：
    
    *   在降维的同时考虑类别标签信息，有助于分类任务。
    *   适合类别数较少、类别间线性可分的场景。
*   **缺点**：
    
    *   对数据的线性可分性有较高要求。
    *   不适合多类别不平衡或类别分布复杂的场景。

**18. t-SNE（t-Distributed Stochastic Neighbor Embedding）**

*   **解释**：  
    t-SNE 是一种非线性降维算法，适用于高维数据的可视化。它通过最小化高维空间和低维空间的相似度分布之间的 KL 散度，将高维数据映射到低维空间中，以保持数据的局部结构。
    
*   **应用场景**：
    
    *   高维数据的降维和可视化，如图像数据、文本数据等。
    *   需要展示数据局部结构的场景，如聚类结果可视化。
*   **优点**：
    
    *   能有效保持高维数据在低维空间的局部结构。
    *   降维效果好，适合用于数据可视化。
*   **缺点**：
    
    *   计算复杂度高，处理大规模数据时速度慢。
    *   对参数敏感，结果不稳定，难以调参。

#### 3. 半监督学习算法（Semi-Supervised Learning）

**19. 半监督 SVM（Semi-Supervised SVM）**

*   **解释**：  
    半监督 SVM 是一种结合有标签数据和无标签数据进行分类的模型。它在传统 SVM 的基础上，通过加入无标签数据的损失项，最大化无标签数据的决策边界间隔，从而提升模型的分类性能。
    
*   **应用场景**：
    
    *   有大量无标签数据和少量有标签数据的场景，如医学图像标注、文本分类。
    *   标签数据获取成本高或样本不平衡的场景。
*   **优点**：
    
    *   结合有标签数据和无标签数据进行学习，能够提升模型效果。
    *   能利用大量无标签数据进行训练，节省标注成本。
*   **缺点**：
    
    *   对无标签数据的分布假设敏感，如果假设不成立，可能会降低模型效果。
    *   训练复杂度高，调参较为复杂。

#### 4. 强化学习算法（Reinforcement Learning）

**20. Q 学习（Q-Learning）**

*   **解释**：  
    Q 学习是一种基于值函数的强化学习算法，通过对状态 - 动作对进行评分来指导代理的行为策略。算法通过更新 Q 值表来逼近最优策略，从而在每个状态下选择使累计奖励最大的动作。
    
*   **应用场景**：
    
    *   离散状态和动作空间

的任务，如迷宫导航、棋类游戏等。

*   需要学习最优策略的场景，如机器人控制、资源分配。
    
*   **优点**：
    
    *   能有效处理部分可观测环境中的最优策略学习。
    *   无需模型信息，通过与环境的交互即可学习策略。
*   **缺点**：
    
    *   在高维状态空间下，表格形式的 Q 值难以表示，需要大量内存。
    *   需要大量的探索和训练才能收敛到最优解。

**21. 深度 Q 网络（DQN, Deep Q Network）**

*   **解释**：  
    DQN 是结合深度学习和强化学习的一种算法，通过神经网络逼近 Q 值，解决了传统 Q 学习在高维状态空间下的局限性。它使用经验回放和目标网络来稳定训练过程。
    
*   **应用场景**：
    
    *   高维状态空间的任务，如 Atari 游戏、无人驾驶等。
    *   需要学习复杂策略的场景，如机器人控制、视频游戏。
*   **优点**：
    
    *   能处理高维状态空间，通过神经网络逼近 Q 值。
    *   结合深度学习和强化学习，能在复杂环境中学习有效策略。
*   **缺点**：
    
    *   训练不稳定，依赖于经验回放和目标网络。
    *   对超参数敏感，训练时间长，易陷入局部最优。

#### 5. 集成学习算法（Ensemble Learning）

**22. 袋装法（Bagging）**

*   **解释**：  
    袋装法是一种集成学习方法，通过对原始数据进行多次随机采样（有放回）生成多个子数据集，并分别训练多个基模型。最终通过这些基模型的投票或平均结果来提高模型的泛化能力。
    
*   **应用场景**：
    
    *   适用于不稳定的模型，如决策树、神经网络等。
    *   分类和回归任务，如随机森林、保险风险预测等。
*   **优点**：
    
    *   能有效降低模型的方差，提高模型稳定性。
    *   能处理高维数据，对噪声数据鲁棒性强。
*   **缺点**：
    
    *   训练多个模型，计算复杂度高。
    *   对偏差大的模型效果有限。

**23. 提升法（Boosting）**

*   **解释**：  
    提升法是一种集成学习方法，通过训练多个弱学习器来逐步降低训练误差。每个学习器会在前一个学习器错误分类的样本上赋予更高权重，从而在后续训练中更加关注这些难以分类的样本。
    
*   **应用场景**：
    
    *   各种回归和分类任务，如广告点击率预测、信用评分。
    *   需要高精度模型的任务，如 Kaggle 竞赛。
*   **优点**：
    
    *   能有效降低偏差，提高模型精度。
    *   适合处理复杂的非线性关系。
*   **缺点**：
    
    *   训练时间长，对异常值敏感，易过拟合。
    *   模型解释性差，调参复杂。

**24. 堆叠法（Stacking）**

*   **解释**：  
    堆叠法是一种集成学习方法，通过训练多个**基模型**，将它们的**预测结果作为新的输入特征**，进一步**训练一个元模型**。元模型综合基模型的预测结果，生成最终的预测值。【类似模型蒸馏】
    
*   **应用场景**：
    
    *   需要集成多种不同模型的任务，如信用评分、客户流失预测。
    *   在传统单模型效果不佳的场景。
*   **优点**：
    
    *   能综合不同模型的优势，提升整体模型的表现。
    *   灵活性强，可以使用多种不同的模型和组合方式。
*   **缺点**：
    
    *   计算复杂度高，容易过拟合。
    *   需要对基模型和元模型进行仔细调优，难度大。

在实际应用中，选择合适的算法取决于数据特点、任务需求以及模型的可解释性和性能要求。通过结合多种算法和策略，可以更好地解决实际问题。

![](https://i-blog.csdnimg.cn/direct/29b94364f7ca446e86c3a10e1cc488b1.png)

感知机（Perceptron）
---------------

感知机是机器学习中**最基本的线性分类模型之一**，只有**一个输入层**和**一个输出层**，**没有隐藏层**。是一个**简单的线性分类器**，只适用于线性可分的数据集。它最初由 Frank Rosenblatt 于 1957 年提出，**用于解决二分类问题**。感知机的目标是**找到一个能够将两个类别的样本进行线性分割的超平面**（即**线性决策边界**）。

### 模型定义

感知机模型的主要思想是：通过一个**线性函数将输入的特征 x 映射到一个输出类别 y** ，其基本形式如下：

**公式**：

f (x) = sign ( w ⋅ x + b ) f(x) = \text{sign}(w \cdot x + b) f(x)=sign(w⋅x+b)

*   x x x 是输入的特征向量，表示样本的数据。
*   w w w 是权重向量，表示每个特征的重要性。
*   b b b 是偏置项，它可以**移动分类边界**，使得模型更加灵活。
*   w ⋅ x w \cdot x w⋅x 是权重和输入的点积，这个值**决定了输入样本在分类边界的哪一侧**。
*   sign (⋅) \text{sign}(\cdot) sign(⋅) 是符号函数，它将点积的结果映射为 +1 或 -1，用于区分两个类别：
    *   如果 w ⋅ x + b > 0 w \cdot x + b > 0 w⋅x+b>0，则 f (x) = 1 f(x) = 1 f(x)=1，即样本属于正类。
    *   如果 w ⋅ x + b < 0 w \cdot x + b < 0 w⋅x+b<0，则 f (x) = − 1 f(x) = -1 f(x)=−1，即样本属于负类。

### 训练过程

感知机的训练过程的核心思想是：**对于每个错误分类的样本，调整权重和偏置**，使其更接近正确分类。（类似神经网络中的**前向传播**和**反向传播**）其学习规则如下：  
以下是图片内容的文字提取：

1.  **初始化**：将权重 w w w 和偏置 b b b 初始化为 0 或随机小值。
    
2.  **遍历数据集**：对训练集中的每个样本 ( x i , y i ) (x_i, y_i) (xi​,yi​)，其中 y i y_i yi​ 是样本的真实类别（取值为 1 或 -1）。
    
3.  **判断分类结果**：计算 y i ( w ⋅ x i + b ) y_i(w \cdot x_i + b) yi​(w⋅xi​+b)。
    
    *   如果 y i ( w ⋅ x i + b ) ≤ 0 y_i(w \cdot x_i + b) \leq 0 yi​(w⋅xi​+b)≤0，表示分类错误，需要更新权重和偏置。
    *   如果 y i ( w ⋅ x i + b ) > 0 y_i(w \cdot x_i + b) > 0 yi​(w⋅xi​+b)>0，表示分类正确，无需更新。
4.  **更新规则**（对于错误分类的样本）：  
    w = w + η ⋅ y i ⋅ x i w = w + \eta \cdot y_i \cdot x_i w=w+η⋅yi​⋅xi​  
    b = b + η ⋅ y i b = b + \eta \cdot y_i b=b+η⋅yi​  
    其中， η \eta η 是学习率，用于控制每次调整的幅度。
    
5.  **重复步骤 2-4**，直到所有样本被正确分类或达到最大迭代次数。
    

### 优势和局限性

*   **优势**：
    
    *   **简单易实现**：感知机是最基础的线性分类模型，理论简单，容易实现。
    *   **收敛性保证**：对于**线性可分数据集**，感知机可以保证在有限次迭代内**收敛到一个可以完全分开的超平面**。
*   **局限性**：
    
    *   **不适用于线性不可分数据**：感知机只能处理线性可分的数据集，对于线性不可分的数据集，无法给出合适的分类边界。
    *   **对噪声敏感**：感知机对异常点和噪声点敏感，可能导致模型过拟合。
    *   **无法输出概率**：感知机只能给出硬分类结果（-1 或 1），无法输出分类的概率或置信度。

### 感知机的扩展

感知机模型是很多复杂模型的基础，例如：

*   **多层感知机（MLP, Multi-Layer Perceptron）**：由多个感知机堆叠形成，是**神经网络的基础模型**。
*   **支持向量机（SVM, Support Vector Machine）**：感知机的扩展版本，能够找到**最大间隔的分类超平面**，适用于**线性不可分**数据的处理。

多层感知机（MLP, Multilayer Perceptron）
---------------------------------

### 定义

多层感知机（MLP）是感知机的扩展版本，它属于**前馈神经网络**，具备**多层结构**，**可以处理更复杂的非线性分类问题**。MLP 是神经网络中最基础的结构，至少包括一个**输入层**、一个或多个**隐藏层**和一个**输出层**。

### 工作原理

MLP 通过多个**神经元层的组合**来学习复杂的非线性关系。每一层的神经元将接收上一层的输出，并通过**激活函数**（如 ReLU、Sigmoid）进行**非线性变换**，然后传递给下一层。输出层则根据最后一层的神经元输出结果作出分类或预测。

**核心概念**：

*   **前向传播（Forward Propagation）**：数据从输入层经过隐藏层，逐层计算，最后到达输出层。
*   **反向传播（Backpropagation）**：通过计算损失函数的梯度（如交叉熵或均方误差）来调整权重和偏置，更新过程使用梯度下降算法。  
    MLP 通过多次前向传播和反向传播来优化模型参数，从而在复杂的非线性空间中找到最优的决策边界。

> 前向传播和反向传播参考：[深度学习——**前向传播与反向传播**、神经网络（前馈神经网络与反馈神经网络）、常见算法概要汇总](https://lichuachua.blog.csdn.net/article/details/142515911)

### 优势和局限性

**优势**

*   **能处理非线性分类**：MLP 能够通过隐藏层和非线性激活函数**处理复杂的非线性分类问题**。
*   **多层结构学习复杂的特征关系**：隐藏层允许 MLP 学习复杂的特征关系，增加模型的表达能力。

**局限性**：

*   **训练时间长**：随着网络层数和参数的增加，训练时间也会大幅增加。
*   **需要大量数据**：MLP 通常需要大量的训练数据来表现出优势。
*   **易过拟合**：在数据不足的情况下，MLP 可能会过拟合训练集，需通过正则化或其他方法来避免过拟合。

支持向量机（SVM, Support Vector Machine）
----------------------------------

### 定义

支持向量机（SVM）是一种用于**分类和回归**的强大算法。SVM 的目标是通过找到一个能够**最大化类间间隔（Margin）的超平面**，将不同类别的样本分开。SVM 可以处理**线性和非线性**分类任务，尤其在**高维数据集上表现良好**。

### 工作原理

SVM 试图找到一个最佳的决策超平面，使得正类和负类之间的间隔最大化。SVM 使用以下两个核心概念：

*   **最大间隔超平面**：SVM 寻找使得类别之间的间隔（即最小距离）最大的超平面，增强模型的泛化能力。
*   **支持向量**：支持向量是位于**分类边界上的样本点**，它们决定了超平面的最优位置。

### 核函数（Kernel Function）

对于**线性不可分数据**，SVM 引入了**核函数（Kernel Trick）** 进行 **非线性映射** ，将**数据映射到更高维空间**，在该空间中数据变得线性可分。常用的核函数有线性核、多项式核、高斯核（RBF）等。

#### 工作原理

核函数的作用是**通核函数`隐式地`计算样本对之间的相似性，将原始的低维数据映射到高维空间，使得在该高维空间中数据可以线性分离**。

直接在高维空间对每个数据点进行计算会非常昂贵，因为每个特征都需要映射到高维空间，而这种映射可能是上千维甚至无限维的，计算量巨大。因此，SVM 使用了**核函数（Kernel Function）**来**避免显式地进行高维映射**。

核函数能够**直接在低维空间中计算两个样本在高维空间中的 “相似性”（即高维映射后的点积）**。这就意味着，我们不需要真正把数据点映射到高维空间，而是通过核函数计算结果**隐式地得到**了高维空间中的结果。这一过程称为**核技巧（Kernel Trick）**。

> 核技巧的核心思想是：假设我们有一个**映射函数 ϕ (x) \phi(x) ϕ(x)**，它将数据点 x x x **从低维空间映射到高维空间**。如果我们想在高维空间中计算两个数据点 x x x 和 y y y 的点积 ϕ (x) ⋅ ϕ ( y ) \phi(x) \cdot \phi(y) ϕ(x)⋅ϕ(y)，核技巧允许我们直接通过核函数 K ( x , y ) K(x, y) K(x,y) 来计算，而**不需要显式计算** ϕ (x) \phi(x) ϕ(x) 和 ϕ (y) \phi(y) ϕ(y)。即：  
> K ( x , y ) = ϕ (x) ⋅ ϕ ( y ) K(x, y) = \phi(x) \cdot \phi(y) K(x,y)=ϕ(x)⋅ϕ(y)  
> 通过核函数，我们可以直接在低维空间中计算出在高维空间的点积值，避免了高维映射的计算。

#### 类型

1.  **线性核（Linear Kernel）**
    
    *   **公式**：  
        K ( x i , x j ) = x i ⋅ x j K(x_i, x_j) = x_i \cdot x_j K(xi​,xj​)=xi​⋅xj​
    *   **含义**：**直接计算两个样本的点积**，适合**数据本身线性可分的情况**。线性核**不进行任何非线性映射**，仅在原始空间中计算样本的内积。
    *   **参数**：无特定的参数。
    *   **应用场景**：适用于**特征数量大而样本数量少**的数据集，例如文本分类问题中的文档分类。
2.  **多项式核（Polynomial Kernel）**
    
    *   **公式**：  
        K ( x i , x j ) = ( x i ⋅ x j + c ) d K(x_i, x_j) = (x_i \cdot x_j + c)^d K(xi​,xj​)=(xi​⋅xj​+c)d
    *   **含义**：通过**引入多项式项**，使得模型能够拟合更复杂的非线性关系。
    *   **参数**：
        *   **c c c**：常数项，调节映射的偏移。通常为 1，**确保模型的灵活性**。
        *   **d d d**：多项式的阶数（degree），**控制映射的复杂性**。阶数越高，模型拟合能力越强，但也**更容易过拟合**。
    *   **应用场景**：适合**数据分布非线性**且有较**明显的多项式关系**的数据集。
3.  **径向基函数核（Radial Basis Function Kernel, RBF Kernel）**
    
    *   **公式**：  
        K ( x i , x j ) = exp ⁡ ( − ∥ x i − x j ∥ 2 2 σ 2 ) K(x_i, x_j) = \exp\left(-\frac{\|x_i - x_j\|^2}{2\sigma^2}\right) K(xi​,xj​)=exp(−2σ2∥xi​−xj​∥2​)  
        或者写作  
        K ( x i , x j ) = exp ⁡ ( − γ ∥ x i − x j ∥ 2 ) K(x_i, x_j) = \exp(-\gamma \|x_i - x_j\|^2) K(xi​,xj​)=exp(−γ∥xi​−xj​∥2)
    *   **含义**：RBF 核**通过高斯分布**将样本映射到**一个无穷维的空间**，能够很好地处理非线性问题。RBF 核的值随着样本之间距离的增加而迅速衰减，因此更关注局部特征。
    *   **参数**：
        *   **σ \sigma σ**：带宽参数，**控制样本之间的相似性范围**。较小的 σ \sigma σ 值会使核函数更集中于样本附近，更适合细粒度模式；较大的 σ \sigma σ 值使核函数范围更广，模型更具全局性。
        *   **γ \gamma γ**：通常定义为 γ = 1 2 σ 2 \gamma = \frac{1}{2\sigma^2} γ=2σ21​，因此调节 γ \gamma γ 相当于调节 σ \sigma σ 的效果。较大的 γ \gamma γ 使得模型复杂度增加，容易过拟合；较小的 γ \gamma γ 使得模型泛化能力更强。
    *   **应用场景**：RBF 核是 SVM 中最常用的核函数之一，**适合大多数非线性数据**，尤其是结构复杂的数据集。
4.  **Sigmoid 核（Sigmoid Kernel）**
    
    *   **公式**：  
        K ( x i , x j ) = tanh ⁡ ( α ⋅ x i ⋅ x j + c ) K(x_i, x_j) = \tanh(\alpha \cdot x_i \cdot x_j + c) K(xi​,xj​)=tanh(α⋅xi​⋅xj​+c)
    *   **含义**：Sigmoid 核类似于神经网络中的激活函数，使得 SVM 模型的表达能力接近于浅层神经网络。
    *   **参数**：
        *   **α \alpha α**：比例因子，**控制样本点的内积影响大小**，类似于学习率的作用。
        *   **c c c**：偏移量，**控制样本点在 Sigmoid 函数中的位置**。
    *   **应用场景**：Sigmoid 核在某种程度上可以模仿神经网络的效果，但在实际应用中**较少用到**，通常在实验时尝试。

#### 如何选择

*   **线性核**：当数据在原始空间中已经接近线性可分时，线性核是不错的选择，计算量较小，适合高维稀疏数据（如文本分类）。
*   **多项式核**：**适合具有多项式关系**的非线性数据，通过调整多项式的阶数来控制模型的复杂度。
*   **RBF 核**：是一种通用的核函数，**适合大多数非线性数据集**，可以捕捉复杂的局部特征，是 SVM 中**最常用的核函数**之一（如图像分类）。
*   **Sigmoid 核**：类似于神经网络中的激活函数，但实际应用中不常用，通常是实验性地用于测试。

### 软间隔与硬间隔（Soft Margin & Hard Margin）

引入了**软间隔**（soft margin）概念，**引入松弛变量允许一些数据点被错误分类**（通过引入松弛变量），从而能够处理线性不可分的数据。

*   **硬间隔（Hard Margin）**：
    
    *   假设数据是线性可分的，SVM 的目标是找到一个能够将所有样本点完全分开的超平面。
    *   在**硬间隔下**，**所有样本点都满足** y i ( w ⋅ x i + b ) ≥ 1 y_i(w \cdot x_i + b) \geq 1 yi​(w⋅xi​+b)≥1 的约束。
    *   缺点是**对异常值和噪声数据敏感**，导致模型的泛化能力差。
*   **软间隔（Soft Margin）**：
    
    *   软间隔**允许部分数据点不满足严格的分类条件**，即允许某些样本点可以落入分类间隔中或被误分类。
    *   引入松弛变量 ξ i \xi_i ξi​ 来度量样本的违约程度，优化目标变为：  
        min ⁡ 1 2 ∥ w ∥ 2 + C ∑ i = 1 N ξ i \min \frac{1}{2} \| w \|^2 + C \sum_{i=1}^N \xi_i min21​∥w∥2+Ci=1∑N​ξi​
        *   其中， C C C 是惩罚系数，用于平衡间隔大小和误分类点的数量。
    *   软间隔能够处理数据中的噪声和异常值，具有更好的泛化能力。

### 损失函数

#### 硬间隔 SVM 损失函数

硬间隔 SVM 假设数据是**线性可分的**，其目标是找到一个最优超平面，使所有样本点都在分类边界的正确一侧。

**优化目标**：  
硬间隔 SVM 的优化目标是最大化间隔，同时确保所有样本点都被正确分类。该目标可以表示为：  
min ⁡ 1 2 ∥ w ∥ 2 \min \frac{1}{2} \| w \|^2 min21​∥w∥2  
其中：

*   w w w 是超平面的权重向量（法向量），确定了超平面的方向。

**约束条件**：  
对于每个样本 ( x i , y i ) (x_i, y_i) (xi​,yi​)，要求满足：  
y i ( w ⋅ x i + b ) ≥ 1 y_i (w \cdot x_i + b) \geq 1 yi​(w⋅xi​+b)≥1

其中：

*   w w w 是超平面的权重向量（法向量），确定了超平面的方向。
*   b b b 是偏置项。
*   y i y_i yi​ 是标签，取值为 +1 或 -1。

硬间隔 SVM 的损失函数只适用于**线性可分的情况**，对噪声和异常值非常敏感，实际应用中并不常用。

#### 软间隔 SVM 损失函数（Soft Margin SVM）

引入**软间隔**的概念，以允许部分样本点落入分类间隔中，或者被误分类。软间隔 SVM 引入了**松弛变量** ξ i \xi_i ξi​ 来度量样本的误分类程度。

**优化目标**：  
软间隔 SVM 的优化目标是**最大化间隔**，同时**最小化误分类损失**。优化目标为：  
min ⁡ 1 2 ∥ w ∥ 2 + C ∑ i = 1 N ξ i \min \frac{1}{2} \| w \|^2 + C \sum_{i=1}^N \xi_i min21​∥w∥2+Ci=1∑N​ξi​

其中：

*   **1 2 ∥ w ∥ 2 \frac{1}{2} \| w \|^2 21​∥w∥2**：表示间隔最大化项。
*   **∑ i = 1 N ξ i \sum_{i=1}^N \xi_i ∑i=1N​ξi​**：表示误分类损失项。
*   **C C C**：是**惩罚系数**，用于平衡间隔大小和误分类损失之间的权衡。较大的 C C C 值会使模型更关注误分类损失，容易过拟合；较小的 C C C 值会让模型更关注间隔大小，具有更好的泛化能力。

**约束条件**：  
在软间隔下，每个样本需要满足以下约束条件：  
y i ( w ⋅ x i + b ) ≥ 1 − ξ i , ξ i ≥ 0 y_i (w \cdot x_i + b) \geq 1 - \xi_i, \quad \xi_i \geq 0 yi​(w⋅xi​+b)≥1−ξi​,ξi​≥0

其中：

*   ξ i \xi_i ξi​ 是松弛变量，表示样本 x i x_i xi​ 的误分类程度。
    *   当 ξ i = 0 \xi_i = 0 ξi​=0 时，样本被正确分类且在间隔之外。
    *   当 0 < ξ i ≤ 1 0 < \xi_i \leq 1 0<ξi​≤1 时，样本被正确分类但在间隔之内。
    *   当 ξ i > 1 \xi_i > 1 ξi​>1 时，样本被误分类。

#### 合页损失（Hinge Loss）

使用的是**合页损失函数**（hinge loss），并加入了**正则化项**来控制**分类间隔与误分类的权衡**。SVM 的目标是**最小化损失函数**，同时**最大化分类间隔**。  
SVM 的损失函数还可以用**合页损失函数**（Hinge Loss）来表示。合页损失是一种常用的损失函数，专门用于最大间隔分类问题。其形式如下：

L ( y , f (x) ) = max ⁡ ( 0 , 1 − y ⋅ f ( x ) ) L(y, f(x)) = \max(0, 1 - y \cdot f(x)) L(y,f(x))=max(0,1−y⋅f(x))  
其中：

*   f (x) = w ⋅ x + b f(x) = w \cdot x + b f(x)=w⋅x+b 表示模型的预测值。
*   y y y 是真实标签，取值为 +1 或 -1。

合页损失的作用是对误分类样本进行惩罚，同时鼓励正确分类样本远离分类边界。合页损失的效果如下：

*   当 y ⋅ f (x) ≥ 1 y \cdot f(x) \geq 1 y⋅f(x)≥1 时，损失为 0，表示样本被正确分类且位于分类间隔之外。
*   当 y ⋅ f (x) < 1 y \cdot f(x) < 1 y⋅f(x)<1 时，损失为 1 − y ⋅ f (x) 1 - y \cdot f(x) 1−y⋅f(x)，表示样本位于间隔内或被误分类。

因此，软间隔 SVM 的损失函数也可以重写为：  
min ⁡ 1 2 ∥ w ∥ 2 + C ∑ i = 1 N max ⁡ ( 0 , 1 − y i ( w ⋅ x i + b ) ) \min \frac{1}{2} \| w \|^2 + C \sum_{i=1}^N \max(0, 1 - y_i (w \cdot x_i + b)) min21​∥w∥2+Ci=1∑N​max(0,1−yi​(w⋅xi​+b))

#### 总结

支持向量机的损失函数可以分为硬间隔和软间隔两种：

*   **硬间隔**：适用于**线性可分数据**，只关注最大化分类间隔。
*   **软间隔**：适用于实际**非线性可分的数据**，通过引入松弛变量允许少量误分类，提高模型的泛化能力。
*   **合页损失（Hinge Loss）**：软间隔 SVM 常用的损失函数，**对误分类样本进行惩罚**，并鼓励正确分类样本远离边界。

软间隔 SVM 和合页损失的组合使得 SVM 在处理噪声和异常值方面更具鲁棒性，同时保持良好的分类效果。

### 工作流程

<table><thead><tr><th>步骤</th><th>详细说明</th></tr></thead><tbody><tr><td><strong>数据准备</strong></td><td>收集、整理和预处理数据集，标准化特征。</td></tr><tr><td><strong>选择核函数</strong></td><td>根据数据分布选择合适的核函数，如线性核、多项式核等。</td></tr><tr><td><strong>设置参数</strong></td><td>设置正则化参数 ( C C C ) 和核函数参数（如 γ \gamma γ）。</td></tr><tr><td><strong>构建模型</strong></td><td>通过最大化间隔找到最优超平面。</td></tr><tr><td><strong>训练模型</strong></td><td>通过优化算法求解支持向量、权重和偏置。</td></tr><tr><td><strong>模型验证与调参</strong></td><td>通过交叉验证调整参数，以提升模型性能。</td></tr><tr><td><strong>模型预测</strong></td><td>使用最优超平面对新样本进行分类。</td></tr><tr><td><strong>评估模型</strong></td><td>使用准确率、精确率、召回率等指标评估模型的表现。</td></tr></tbody></table>

### SVM 多分类

SVM 本身是一个二分类模型，处理多分类问题时，通常使用以下几种策略：

#### 一对多（One-vs-Rest, OvR）

针对**每个类别训练一个 SVM 分类器**，将**该类别样本作为正类，其余所有类别样本作为负类**。

> 对于 K 个类别，训练 K 个二分类器，最后选择得分最高的分类器对应的类别作为最终预测结果。

#### 一对一（One-vs-One, OvO）

针对每**两个类别组合训练一个 SVM 分类器**。

> 对于 K K K 个类别，需要训练 K ( K − 1 ) / 2 K(K−1)/2 K(K−1)/2 个二分类器，最终使用投票机制决定类别归属。  
> 每个二分类器**只使用两个类别的样本**进行训练，将这两个类别中的一个作为正类，另一个作为负类，其余类别的数据不参与该分类器的训练。  
> 例如，对于一个有 3 个类别（A、B、C）的数据集，OvO 会训练 3 个二分类器：
> 
> *   分类器 1：用类别 A 和 B 的数据训练，将 A 作为正类，B 作为负类。
> *   分类器 2：用类别 A 和 C 的数据训练，将 A 作为正类，C 作为负类。
> *   分类器 3：用类别 B 和 C 的数据训练，将 B 作为正类，C 作为负类。

### 优势与局限性

**优势**：

*   **线性和非线性分类**：SVM 能处理线性不可分的数据，通过核函数将数据映射到高维空间进行分类。
*   **适合高维数据**：SVM 特别擅长处理高维数据，常用于文本分类、基因数据分析等。
*   **稳健性强**：SVM 通过最大化间隔来提高泛化能力，减少过拟合的可能性。

**局限性**：

*   **计算复杂度高**：当样本数较大时，SVM 的计算成本较高，尤其是在大规模数据集上训练时，效率较低。
*   **核函数选择困难**：SVM 依赖于核函数的选择，不同的数据集需要调试合适的核函数和参数，选择不当可能导致模型表现不佳。

对比
--

### 总结对比

*   **感知机（Perceptron）**：适合**线性分类问题**，模型结构简单、计算效率高，但只能处理线性可分的数据。
*   **多层感知机（MLP）**：具有更强的表达能力，适合**复杂的非线性任务**，但容易过拟合，训练时间较长，需要大量数据来实现优势。
*   **支持向量机（SVM）**：通过最大化分类间隔和使用核函数处理**线性和非线性分类问题**，在**高维小数据集上表现出色**，但计算复杂度较高。

各个模型适合的应用场景不同，选择时应根据具体任务的复杂性、数据规模、非线性程度等进行综合考虑。

以下是**感知机（Perceptron）**、**多层感知机（MLP）** 和 **支持向量机（SVM）** 的详细对比，从多个维度分析它们的区别、优缺点及应用场景。

### 基本概念

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>最基本的线性二分类模型，使用线性方程区分正类和负类。</td><td>一种具有多个隐藏层的神经网络，可以处理非线性问题。</td><td>通过找到最大化间隔的超平面来进行分类，适合线性和非线性分类。</td></tr><tr><td><strong>决策边界</strong></td><td>线性分类器。只能找到线性决策边界。</td><td>通过多个隐藏层和非线性激活函数找到复杂的非线性决策边界。</td><td>寻找最大间隔的线性或非线性超平面。</td></tr></tbody></table>

### 模型结构

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>层数</strong></td><td>单层结构，只有输入层和输出层。</td><td>多层结构，包含输入层、隐藏层和输出层。</td><td>没有层次结构，通过超平面划分数据。</td></tr><tr><td><strong>激活函数</strong></td><td>无激活函数，仅使用线性分隔。</td><td>每层使用非线性激活函数（如 ReLU, Sigmoid）。</td><td>无激活函数（线性 SVM）；核函数（非线性 SVM）。</td></tr><tr><td><strong>非线性处理</strong></td><td>无法处理非线性问题。</td><td>通过隐藏层和非线性激活函数处理复杂的非线性关系。</td><td>通过核技巧处理非线性问题。</td></tr></tbody></table>

### 学习方式和优化

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>学习算法</strong></td><td>感知机算法，通过误分类更新权重，简单高效。</td><td>通过前向传播和反向传播算法训练，使用梯度下降优化。</td><td>通过凸优化算法，最大化分类间隔，使用 Hinge Loss 和正则化项。</td></tr><tr><td><strong>损失函数</strong></td><td>无损失函数，基于误分类更新权重。</td><td>常用均方误差或交叉熵损失函数。</td><td>Hinge Loss（合页损失），主要用于最大化分类间隔。</td></tr><tr><td><strong>参数更新</strong></td><td>直接更新权重和偏置，按学习率调整误分类样本的权重。</td><td>通过反向传播和梯度下降优化所有层的权重。</td><td>基于支持向量更新模型参数，找到支持向量确定超平面。</td></tr></tbody></table>

### 适用性和能力

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>适用问题类型</strong></td><td>只能处理<strong>线性可分</strong>的二分类问题。</td><td>适用于<strong>非线性分类</strong>和回归任务，支持多分类任务。</td><td>适用于线性和非线性分类任务，也可用于回归。</td></tr><tr><td><strong>对数据的要求</strong></td><td>只能处理线性可分数据。</td><td>可以处理复杂数据，适合大规模数据集和高维数据。</td><td>适合处理小规模且高维的数据，尤其是线性不可分数据。</td></tr><tr><td><strong>模型复杂性</strong></td><td>模型简单，计算成本低。</td><td>模型复杂，包含多个隐藏层，计算开销大。</td><td>复杂度高，尤其在大数据集上训练时，计算开销较大。</td></tr></tbody></table>

### 优缺点

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>优点</strong></td><td>- 简单易实现。<br>- 计算开销低。</td><td>- 具有较强的表达能力，可处理非线性问题。<br>- 适合处理复杂任务。</td><td>- 具有很强的泛化能力。<br>- 通过核函数处理非线性问题。<br>- 在高维数据中表现良好。</td></tr><tr><td><strong>缺点</strong></td><td>- 只能处理线性可分问题。<br>- 不能处理多分类任务。</td><td>- 容易过拟合，需要大量数据来避免过拟合。<br>- 训练时间长。</td><td>- 计算复杂度较高，尤其是在大数据集上训练时。<br>- 对于噪声数据较为敏感。</td></tr><tr><td><strong>过拟合风险</strong></td><td>过拟合风险低。</td><td>由于模型复杂，容易过拟合，需要正则化或 Dropout。</td><td>通过最大化间隔和正则化项减少过拟合的风险。</td></tr></tbody></table>

### 应用场景

<table><thead><tr><th><strong>特性</strong></th><th><strong>感知机（Perceptron）</strong></th><th><strong>多层感知机（MLP）</strong></th><th><strong>支持向量机（SVM）</strong></th></tr></thead><tbody><tr><td><strong>常见应用</strong></td><td>- 简单的二分类问题。</td><td>- 图像分类、自然语言处理（NLP）、回归任务。</td><td>- 文本分类、图像识别、基因数据分析、金融数据分析。</td></tr><tr><td><strong>典型使用场景</strong></td><td>- 小规模、简单的二分类任务。</td><td>- 需要学习复杂的非线性关系和特征提取的问题。</td><td>- 适合处理高维数据和小样本问题，尤其是线性不可分问题。</td></tr></tbody></table>

![](https://i-blog.csdnimg.cn/direct/3946787573874d7b832192a92144b213.png)

KNN
---

### 思想

KNN（K-Nearest Neighbors，K 近邻算法）是一种基于实例的**监督学习**算法，广泛应用于**分类和回归任务**中。它的主要思想是：对于给定的样本点，**找到其在特征空间中距离最近的 K 个训练样本，并以这些最近邻的样本的类别或数值来预测该样本的类别或数值**。

### 工作原理

1.  **计算距离**：**计算待分类的样本点与所有训练样本点之间的距离**。
2.  **选择 K 个最近邻样本**：根据计算出的距离，从训练集中**选择 K 个距离最近的样本**点。
3.  **投票或平均**：
    *   对于分类任务，选择这 **K 个样本中出现次数最多的类别**作为预测结果。
    *   对于回归任务，取这 **K 个样本的平均值**作为预测结果。

### K 值选择

*   **K 值**是 KNN 算法中的一个**超参数**，表示选择的邻居数量。K 值的选择非常关键：
    *   如果 K 值**过小**（如 K=1），模型可能会**过拟合**，对噪声数据过于敏感。
    *   如果 K 值**过大**，模型可能会**欠拟合**，因为更多的邻居可能会包含不同类别的样本，从而影响分类结果。

#### 交叉验证

*   **交叉验证**是选择合适 K 值的常用方法。通过交叉验证，我们可以**尝试多个不同的 K 值**，并通过**在验证集上**的表现（如准确率、F1 分数等）来**选择表现最好的 K 值**。

> *   **步骤**：  
>     1. 将训练数据集划分为若干个子集（如 5 折或 10 折交叉验证），每次取其中一个子集作为验证集，剩下的 (k-1) 个子集作为训练集。。  
>     2. 对于每个候选 K 值，进行 KNN 训练并计算验证集上的预测性能（例如准确率）。  
>     3. 选择在交叉验证中性能最佳的 K 值作为最终模型的参数。

#### 类似 K-means 的肘部法

*   在某些情况下，可以绘制**不同 K 值**下模型的**误差曲线**或**分类错误率曲线**，观察曲线的趋势。当误差随着 K 值增大而急剧下降，然后趋于平缓时，那个转折点（类似 “肘部”）的 K 值就是理想的选择。

> **误差曲线**或**分类错误率曲线**：
> 
> *   X 轴 表示 K 值（即最近邻的个数）
> *   Y 轴 表示 模型的误差值 / 分类错误率
> 
> 本质上也是使用类似交叉验证，多个 K 值验证最好的是哪个值

> *   **步骤**：  
>     1. 选择不同的 K 值，计算每个 K 值下的测试误差。  
>     2. 绘制误差随着 K 值变化的曲线。  
>     3. 找到误差曲线的拐点，即误差下降速度变缓的地方（通常 K 值稍小的点）。

#### 经验选择法 / 奇数优先

*   在很多情况下，K 值的选择可以通过经验来做出初步估计，通常选取**较小的奇数值**，如 (K=3, 5, 7)。这样做的目的是避免平票的情况（即 KNN 中相同数量的邻居属于不同类别）。

> *   对于大多数分类任务，**K 值的初始范围**通常是：  
>     - 小规模数据集：**K=3**、**K=5** 或 **K=7** 常常是一个不错的起点。  
>     - 大规模数据集：可以选择较大的 K 值，具体取决于数据集的规模和类别分布。

#### 加权 KNN

*   对距离的样本希望赋予不同的权重，可以使用**加权 KNN**。在加权 KNN 中，**距离样本越近的邻居会赋予更高的权重**，常见的权重分配方式是**反比例加权**：

Weight ( x i ) = 1 d ( x i , x ) \text{Weight}(x_i) = \frac{1}{d(x_i, x)} Weight(xi​)=d(xi​,x)1​

这种方式在 K 值较大时，能够有效增强模型对近邻样本的关注，避免远离的噪声样本影响分类结果。

### 距离度量

#### 欧氏距离（Euclidean Distance）

欧氏距离是**最常用的**距离度量方式，用于度量两个点在 n 维**空间中的直线距离**。它是两个点之间的 “直线” 距离，表示为：  
d ( x , y ) = ∑ i = 1 n ( x i − y i ) 2 d(x, y) = \sqrt{\sum_{i=1}^n (x_i - y_i)^2} d(x,y)=i=1∑n​(xi​−yi​)2 ​  
其中：

*   x x x 和 y y y 表示两个样本点。
*   x i x_i xi​ 和 y i y_i yi​ 分别是样本 x x x 和 y y y 在第 i i i 个特征上的取值。
*   n n n 是特征的维度数。  
    特点：
*   适合度量**连续数据的距离**。
*   **受数据量纲影响较大**，不适用于不同量纲的数据比较。

> 量纲是（如重量、温度、距离等），可以使用**特征缩放（归一化和标准化）**，减少特征之间的量纲差异。

#### 曼哈顿距离（Manhattan Distance）

曼哈顿距离也称为 **L1 距离**或**城市街区距离** ，它是两个点在 n 维空间中**各维度之差的绝对值之和**。表示为：

d ( x , y ) = ∑ i = 1 n ∣ x i − y i ∣ d(x, y) = \sum_{i=1}^n |x_i - y_i| d(x,y)=i=1∑n​∣xi​−yi​∣  
其中：

*   x x x 和 y y y 表示两个样本点。
*   x i x_i xi​ 和 y i y_i yi​ 分别是样本 x x x 和 y y y 在第 i i i 个特征上的取值。
*   n n n 是特征的维度数。

特点：

*   适用于**离散数据和分布不均匀的数据**。
*   更加鲁棒，适用于**高维空间**中。

#### 切比雪夫距离（Chebyshev Distance）

切比雪夫距离表示在**所有维度上最大的差距**，即两个向量在每个坐标维度上最大距离的最小值。其公式为：

d ( x , y ) = max ⁡ i ∣ x i − y i ∣ d(x, y) = \max_i |x_i - y_i| d(x,y)=imax​∣xi​−yi​∣  
其中：

*   x x x 和 y y y 表示两个样本点。
*   x i x_i xi​ 和 y i y_i yi​ 分别是样本 x x x 和 y y y 在第 i i i 个特征上的取值。

特点：

*   适用于**棋盘格状的空间度量**，例如国际象棋中的国王步数。
*   衡量所有维度中最大的距离，适用于某一维度差距明显的情况。

#### 闵可夫斯基距离（Minkowski Distance）

闵可夫斯基距离是**欧氏距离和曼哈顿距离的广义形式**，它引入了一个**参数 (p)**，用于控制距离的度量方式。其公式为：

d ( x , y ) = ( ∑ i = 1 n ∣ x i − y i ∣ p ) 1 p d(x, y) = \left( \sum_{i=1}^n |x_i - y_i|^p \right)^{\frac{1}{p}} d(x,y)=(i=1∑n​∣xi​−yi​∣p)p1​

其中：

*   x x x 和 y y y 表示两个样本点。
*   x i x_i xi​ 和 y i y_i yi​ 分别是样本 x x x 和 y y y 在第 i i i 个特征上的取值。
*   n n n 是特征的维度数。
*   p p p 是一个可调参数，常见的取值为 1（曼哈顿距离）和 2（欧氏距离）。

特点：

*   适用于不同 p p p 值下的多种度量方式。
*   参数 p p p 的选择决定了距离的特性。

#### 余弦相似度（Cosine Similarity）

*   余弦相似度是用来**度量两个向量在空间中的夹角**，用于判断两个向量之间的方向差异。它适用于高维稀疏数据，例如文本分类问题。
*   **值越接近 1，说明两个向量越相似**；值为 0 表示两者垂直无相似性。

Cosine Similarity ( x , y ) = x ⋅ y ∥ x ∥ ∥ y ∥ = ∑ i = 1 n x i y i ∑ i = 1 n x i 2 ∑ i = 1 n y i 2 \text{Cosine Similarity}(x, y) = \frac{x \cdot y}{\|x\| \|y\|} = \frac{\sum_{i=1}^n x_i y_i}{\sqrt{\sum_{i=1}^n x_i^2} \sqrt{\sum_{i=1}^n y_i^2}} Cosine Similarity(x,y)=∥x∥∥y∥x⋅y​=∑i=1n​xi2​ ​∑i=1n​yi2​ ​∑i=1n​xi​yi​​

其中：

*   x ⋅ y x \cdot y x⋅y 是向量 x x x 和 y y y 的点积。
*   ∥ x ∥ \|x\| ∥x∥ 和 ∥ y ∥ \|y\| ∥y∥ 分别是两个向量的范数。
*   x i x_i xi​ 和 y i y_i yi​ 是向量 x x x 和 y y y 在第 i i i 个维度上的分量。

特点：

*   基于高维稀疏数据的应用中，常用于度量文本之间的相似性。如文本分类、文档相似度、推荐系统等

### 总结

以下是 **欧氏距离**、**曼哈顿距离**、**切比雪夫距离**、**闵可夫斯基距离** 和 **余弦相似度** 在 KNN 中的原理、优点和适应场景的对比表格：

<table><thead><tr><th><strong>距离类型</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>适用场景</strong></th><th><strong>不适用场景</strong></th></tr></thead><tbody><tr><td><strong>欧氏距离</strong></td><td>计算<strong>样本间的直线距离</strong>，度量数据点在空间中的绝对距离。</td><td>直观、常用于物理空间的几何距离，适合低维数据。</td><td>适合用于连续特征的距离计算，如坐标点、图像数据等。<br>假设数据的每个维度对距离的贡献是相似的。</td><td>不同量纲的数据（需标准化）。<br>离散特征较多的数据。</td></tr><tr><td><strong>曼哈顿距离</strong></td><td>计算样本在各个<strong>坐标轴上的绝对差值之和</strong>，度量路径距离。</td><td>对异常值不敏感，计算简单，在特征独立时效果较好。适用于<strong>高维空间</strong>中</td><td>离散特征较多的数据集，如文本数据。<br>分布不均匀或维度之间相互独立的数据。</td><td>对特征间存在较强相关性的连续数据效果较差。</td></tr><tr><td><strong>切比雪夫距离</strong></td><td>计算样本在<strong>各个坐标轴上的最大差值</strong>，度量各坐标轴上的最大距离。</td><td>简单有效，适合在棋盘、网格等离散场景中使用。</td><td>适用于棋盘格模型（如国际象棋国王移动步数）。<br>数据维度中某一维度特别重要时使用。</td><td>需要度量整体差异而非单一维度的情况。</td></tr><tr><td><strong>闵可夫斯基距离</strong></td><td><strong>欧氏距离和曼哈顿距离的广义形式</strong>，可通过参数调整度量方式。</td><td>高度灵活，能够模拟多种距离度量方式，适合多样化的场景。适用于<strong>高维空间</strong>中</td><td>可以调整参数 (p) 来适应不同距离度量的需求。<br>当 (p = 1) 时为曼哈顿距离，( p = 2 ) 时为欧氏距离。<br>适用于需要灵活选择距离度量的场景。</td><td>不适合没有明显规律和经验来确定参数 (p) 的数据集。</td></tr><tr><td><strong>余弦相似度</strong></td><td>计算<strong>两个向量的夹角，度量方向上的相似性，而不关注绝对大小或距离</strong>。</td><td>适合<strong>高维稀疏数据</strong>，不受向量大小影响，更多关注方向一致性。</td><td>文本分类、推荐系统、高维稀疏数据（如文档、文本）的相似性度量，尤其是特征量纲不统一或特征分布差异大的情况。</td><td>需要测量绝对距离的场景。</td></tr></tbody></table>

**欧氏距离**、**曼哈顿距离**、**切比雪夫距离** 和 **闵可夫斯基距离** 在低维空间中都可以很好地使用，具体适合场景如下：

*   **欧氏距离**：适合**物理空间中的几何距离**，如二维或三维空间的点距离。
*   **曼哈顿距离**：适合具有**正交结构的路径距离**，如城市街区或简单的网格路径。适用于**高维空间**中
*   **切比雪夫距离**：适合**棋盘路径或二维网格**中的最大步数距离问题。
*   **闵可夫斯基距离**：通过调整参数 (p)，可以**模拟欧氏或曼哈顿距离**，适合不同的场景。适用于**高维空间**中
*   **余弦相似度**：特别适合**高维稀疏数据**，如文本相似度计算。

### 维度灾难

**维度灾难（Curse of Dimensionality）** 是指当**数据的维度增高**时，传统的机器学习**算法**在高维空间中的**表现急剧下降**，主要原因是距离度量、数据稀疏性以及模型复杂度在高维空间中变得难以处理。常见的表现包括：

1.  **距离趋于相同**：在高维空间中，不同数据点之间的距离差异会减小，距离度量如欧氏距离、曼哈顿距离等在高维空间中失去分辨能力。
2.  **数据稀疏性**：高维数据空间变得稀疏，大部分数据点远离彼此，导致模型难以找到有效的模式。
3.  **模型复杂度增加**：随着维度增加，模型需要更多的样本来学习有效的决策边界，否则容易出现过拟合或欠拟合。

**维度灾难**是高维数据中的常见问题，解决这一问题的主要方法有：

*   **降维技术**（如 PCA、LDA、T-SNE、UMAP）。
*   **特征选择**（如过滤法、包裹法、嵌入法）。
*   **合适的距离度量**（如马氏距离、余弦相似度）。
*   **正则化技术**（L1、L2 正则化、Elastic Net）。
*   **核方法**来处理非线性问题。

根据具体的应用场景和数据类型，选择合适的技术和方法，可以有效应对**维度灾难**，提高模型在高维数据下的性能。

#### 1. 降维技术

通过降维，**减少数据的维度**，从而使模型更加有效地处理数据。常见的降维方法有：

> 维度通常指的是特征数量

##### 主成分分析（PCA, Principal Component Analysis）

*   **PCA** 是通过**线性变换**将高维数据投影到低维空间，保持**投影方向上的方差最大化**，进行**无监督的降维**方法。。
*   它适用于具有**线性关系**的数据集，在保留数据主要信息的同时降低维度。
*   **适用场景**：当特征之间具有一定的线性相关性，且希望减少数据的维度时使用。

##### 线性判别分析（LDA, Linear Discriminant Analysis）

*   **LDA** 通过**最大化类间方差**与**最小化类内方差**，寻找最有助于分类的低维子空间。
*   适用于**有监督学习中的分类**问题。
*   **适用场景**：适用于分类任务中，特征与类别标签存在一定关联。

##### T-SNE（t-Distributed Stochastic Neighbor Embedding）

*   **T-SNE** 通过在**高维和低维**空间中**分别计算点对之间的相似度**，然后**最小化两个分布之间的差异** ，使相似数据点在低维空间中靠近。将高维数据映射到二维或三维空间中。
*   **适用场景**：数据可视化，尤其是高维数据集的降维以便于观察聚类或分类结构。

> 详细参考：[机器学习——降维](https://lichuachua.blog.csdn.net/article/details/142435361)

#### 2. 特征选择（Feature Selection）

特征选择是通过选择与目标变量相关的特征，**去掉那些不相关或冗余的特征**，从而降低维度。常用的方法有：

##### 过滤法（Filter Methods）

*   根据特定的统计指标（如**方差**、卡方检验、互信息等）对每个特征进行评分，并选择**得分较高**的特征。
*   **适用场景**：适合大规模数据集的初步特征筛选。

##### 包裹法（Wrapper Methods）

*   使用模型性能评估特征子集的表现，**逐步添加**或**删除特征以找到最佳特征组合**。常见方法包括递归特征消除（RFE）。
*   **适用场景**：特征数量不多时，找到最优的**特征组合**。

##### 嵌入法（Embedded Methods）

*   特征选择**直接嵌入模型的训练过程**，例如 Lasso 回归（**L1 正则化**）会自动选择重要特征，树模型（如**随机森林**）可以给出特征重要性。
*   **适用场景**：结合模型的特征选择，可以自动识别出对模型影响较大的特征。

> 详细参考：[机器学习——特征工程、正则化、强化学习](https://lichuachua.blog.csdn.net/article/details/142452342)

#### 3. 使用合适的距离度量

在高维空间中，某些距离度量失效（如欧氏距离），可以选择更加**适合高维数据的距离度量**：

##### 马氏距离（Mahalanobis Distance）

马氏距离通过**协方差矩阵**对**不同特征进行归一化**，因此能够处理具有不同尺度和相关性的特征，并衡量样本在数据分布中的 “相似性”。

d ( x , y ) = ( x − y ) T Σ − 1 ( x − y ) d(x, y) = \sqrt{(x - y)^T \Sigma^{-1} (x - y)} d(x,y)=(x−y)TΣ−1(x−y) ​

其中：

*   **x x x 和 y y y**：是两个样本点的特征向量。
*   **Σ \Sigma Σ**：是样本数据的协方差矩阵。
*   **Σ − 1 \Sigma^{-1} Σ−1**：是协方差矩阵的逆矩阵。
*   **( x − y ) T Σ − 1 ( x − y ) (x - y)^T \Sigma^{-1} (x - y) (x−y)TΣ−1(x−y)**：是经过协方差矩阵标准化后的二次型。

> **协方差矩阵计算**： Σ = 1 N − 1 ∑ i = 1 N ( x i − μ ) ( x i − μ ) T \Sigma = \frac{1}{N-1} \sum_{i=1}^N (x_i - \mu)(x_i - \mu)^T Σ=N−11​i=1∑N​(xi​−μ)(xi​−μ)T
> 
> 其中：
> 
> *   **N N N** 是样本的数量。
> *   **x i x_i xi​** 是第 k k k 个样本（一个 n n n 维向量）。
> *   **μ \mu μ** 是**特征均值向量**（一个 n n n 维向量），其中每个元素表示对应特征的均值。
> 
> **特征均值向量计算**： μ = 1 N ∑ i = 1 N x i \mu = \frac{1}{N} \sum_{i=1}^N x_i μ=N1​i=1∑N​xi​
> 
> 其中：
> 
> *   **N N N** 是样本的总数量。
> *   **x i x_i xi​** 是第 i i i 个样本的特征向量，也是一个 n n n 维向量。

**适用场景**：高维数据、特征存在相关性时，**度量数据点与中心点的距离**。

##### 余弦相似度（Cosine Similarity）

同上

### 数据结构来加速最近邻搜索

#### KD 树与 Ball 树的比较

<table><thead><tr><th>特性</th><th><strong>KD 树（k-d tree）</strong></th><th><strong>Ball 树（Ball Tree）</strong></th></tr></thead><tbody><tr><td><strong>构建方法</strong></td><td>基于坐标轴的分割，使用超平面划分空间。</td><td>基于距离度量的分割，使用球体划分空间。</td></tr><tr><td><strong>适用距离度量</strong></td><td>欧氏距离、曼哈顿距离等。</td><td>多种距离度量（如欧氏距离、曼哈顿距离等）。</td></tr><tr><td><strong>适用维度</strong></td><td>适合<strong>低维空间</strong>（通常小于 10 维）。数据<strong>分布均匀</strong>、样本数量较少的场景。</td><td>更适合<strong>高维空间</strong>，适应<strong>不均匀</strong>的数据分布、样本数量较多的场景。</td></tr><tr><td><strong>效率</strong></td><td>在低维空间中加速效果显著，但在高维空间中效率下降。</td><td>高维空间中表现较好，尤其是数据分布不均匀时。</td></tr><tr><td><strong>查询加速</strong></td><td>通过逐步缩小超平面区域进行查询。</td><td>通过球体区域划分和过滤来缩小搜索范围。</td></tr><tr><td><strong>构建复杂度</strong></td><td>构建复杂度较低，适合简单的低维场景。</td><td>构建复杂度较高，但能处理更复杂的高维问题。</td></tr></tbody></table>

*   **KD 树**是一种适合**低维均匀分布**（通常小于 10 维）的数据结构，能显著加速最近邻搜索，但在高维空间中效率下降。
*   **Ball 树**在**高维空间**中性能更好，适合**数据分布不均匀**或**维度较高**的场景，是比 KD 树更通用的选择。

如果处理的是低维数据且数据较均匀分布，KD 树是一个较好的选择；而对于高维数据或分布不均的数据，Ball 树更适合。

#### KD 树（KD-Tree）

KD 树（K-Dimensional Tree）是用于快速查找**低维均匀分布数据**的最近邻点。一种适用于低维空间的**二叉搜索树**结构，用于加速最近邻搜索。

##### 工作原理

1.  将数据集沿某一维度（例如**方差最大**的维度）进行分割，**选择中位数作为分割点**。
2.  **递归**地对子节点进行**分割**，直到每个叶子节点包含少量数据点。
3.  通过树的结构进行最近邻搜索，**剪枝**减少计算量。

##### 特点

*   对低维数据（通常维度小于 10）效果较好。
*   数据分布均匀、样本数量较少的场景。

#### Ball 树（Ball Tree）

Ball 树是一种适用于**高维非均匀分布数据**最近邻查找的数据结构，它通过将数据集划分为**球形区域**（ball），并在树中进行组织。每个**节点**表示一个**球体**区域，该球体由一个**中心点**和一个**半径**定义，用于描述和分割数据空间。

##### 工作原理

1.  将数据集划分为**两个球形区域**，确保每个区域中点的数量相等。
2.  **递归**地对每个球形区域进行**分割**，直到每个叶子节点包含少量数据点。
3.  通过树的结构进行最近邻搜索，根据球体之间的距离进行**剪枝**。

> **中心点和半径如何选择？**
> 
> 1.  **确定中心点**：通常选择数据点的**质心**、**中位数**或**最远的两个点**作为中心点，即数据点的几何中心。质心是所有点的坐标平均值。
>     *   选择**质心**作为中心点时，它是**所有数据点**在**每个维度上的平均值**。
>     *   选择**中位数**作为中心点时，通常也是**针对每个维度独立计算中位数**。
>     *   选择数据集中找到两个**距离最远的点**，作为初始的两个种子点。
> 2.  **划分子集**：数据点分配给距离更近的中心点。
> 3.  **计算每个子集的半径**：以该中心点到所有点中**最远点**的距离作为球体的半径，这样球体能够覆盖所有子树中的点。

##### 特点

*   高维数据（通常大于 10 维）。
*   数据分布不均匀，样本量大。

### KNN 优缺点

*   **优点**：
    *   简单、直观、**无需训练过程**，适用于多分类问题。
    *   **对异常值不敏感**。
*   **缺点**：
    *   **计算复杂度高**（随着样本数量增加而增加）。
    *   对高维数据不适用（**维度灾难**）。
    *   对噪声数据敏感，需合理**选择 K 值**。

![](https://i-blog.csdnimg.cn/direct/6f14e7b109fb44109ab2b0b79449c958.png)

贝叶斯
---

### 贝叶斯定理（Bayes’ Theorem）

贝叶斯定理**用于描述事件之间的条件概率关系，解决分类和间接解决回归问题**。它的  
描述了事件 A A A 在事件 B B B 发生后的**条件概率**：

P ( A ∣ B ) = P ( B ∣ A ) ⋅ P (A) P ( B ) P(A | B) = \frac{P(B | A) \cdot P(A)}{P(B)} P(A∣B)=P(B)P(B∣A)⋅P(A)​

在朴素贝叶斯分类中：

*   A A A 表示数据点属于某个类别（如 “垃圾邮件” 或“正常邮件”）。
*   B B B 表示数据点的特征（如邮件的词频）。
*   P(A | B) ：表示在已知**特征 (B)** 的情况下，属于类别 (A) 的概率（**后验概率**）。
*   P(B | A) ：表示在已知**类别 (A)** 的情况下，观察到特征 (B) 的概率（**条件概率**）。
*   P(A) ：事件 A 发生的**先验概率**。
*   P(B) ：事件 B 发生的**先验概率**。

贝叶斯定理的核心思想是**通过已知的先验概率和条件概率，计算某个事件的后验概率**。

### 朴素贝叶斯分类器（Naive Bayes Classifier）

朴素贝叶斯分类器是基于贝叶斯定理的一种简单而有效的分类算法。它的**核心假设**是在给定目标变量的条件下，**所有特征之间是相互独立的**，即 “**条件独立性假设**”。虽然这个假设在**现实中通常不成立**，**但在实际应用中表现得非常好**。

#### 计算步骤

1.  **计算先验概率**：计算每个类别的先验概率 P ( C i ) P(C_i) P(Ci​)，其中 C i C_i Ci​ 表示类别。
    
2.  **计算条件概率 / 似然概率**：对于每个特征，计算在给定类别的条件下特征出现的概率 P ( x j ∣ C i ) P(x_j | C_i) P(xj​∣Ci​)。
    
3.  **应用贝叶斯定理**：计算给定样本属于每个类别的后验概率 P ( C i ∣ x ) P(C_i | x) P(Ci​∣x)，其中 x x x 是特征向量。
    
4.  **做出分类决策**：选择具有**最高后验概率**的类别作为**分类结果**。
    

数学表达式为：

P ( C i ∣ x 1 , x 2 , … , x n ) = P ( C i ) ⋅ P ( x 1 ∣ C i ) ⋅ P ( x 2 ∣ C i ) ⋯ P ( x n ∣ C i ) P ( x 1 , x 2 , … , x n ) P(C_i | x_1, x_2, \dots, x_n) = \frac{P(C_i) \cdot P(x_1 | C_i) \cdot P(x_2 | C_i) \cdots P(x_n | C_i)}{P(x_1, x_2, \dots, x_n)} P(Ci​∣x1​,x2​,…,xn​)=P(x1​,x2​,…,xn​)P(Ci​)⋅P(x1​∣Ci​)⋅P(x2​∣Ci​)⋯P(xn​∣Ci​)​

在实际应用中，由于分母 P ( x 1 , x 2 , … , x n ) P(x_1, x_2, \dots, x_n) P(x1​,x2​,…,xn​) 对所有类别是相同的，所以只需要比较分子部分：

P ( C i ) ⋅ P ( x 1 ∣ C i ) ⋅ P ( x 2 ∣ C i ) ⋯ P ( x n ∣ C i ) P(C_i) \cdot P(x_1 | C_i) \cdot P(x_2 | C_i) \cdots P(x_n | C_i) P(Ci​)⋅P(x1​∣Ci​)⋅P(x2​∣Ci​)⋯P(xn​∣Ci​)

#### 优势

1.  **计算简单**：因为条件独立假设，计算复杂度低，速度快。
2.  **数据需求少**：对小数据集也能表现良好。
3.  **处理多类别问题**：适合处理多类别分类问题。

#### 局限性

1.  **条件独立性假设不现实**：在许多情况下，特征之间并不是独立的，假设不成立时分类器效果可能下降。
2.  **对数据格式敏感**：在某些应用场景中，对特征的处理和分布的要求较高。

### 朴素贝叶斯的三种常见变体

根据数据的不同特性，朴素贝叶斯有三种常见的变体模型：高斯朴素贝叶斯、多项式朴素贝叶斯和伯努利朴素贝叶斯。它们分别适用于不同类型的数据和应用场景。

#### 1. 高斯朴素贝叶斯（Gaussian Naive Bayes）

高斯朴素贝叶斯**连续特征数据，假设特征服从高斯分布（正态分布）**。如身高、体重。

**假设**：每个类别 C i C_i Ci​ 下的特征 x j x_j xj​ 服从正态分布：  
P ( x j ∣ C i ) = 1 2 π σ C i 2 exp ⁡ ( − ( x j − μ C i ) 2 2 σ C i 2 ) P(x_j | C_i) = \frac{1}{\sqrt{2 \pi \sigma_{C_i}^2}} \exp \left( -\frac{(x_j - \mu_{C_i})^2}{2 \sigma_{C_i}^2} \right) P(xj​∣Ci​)=2πσCi​2​ ​1​exp(−2σCi​2​(xj​−μCi​​)2​)  
其中， μ C i \mu_{C_i} μCi​​ 和 σ C i \sigma_{C_i} σCi​​ 分别是类别 C i C_i Ci​ 下特征 x j x_j xj​ 的均值和标准差。

> *   **适用场景**：
>     *   特征为连续值（如身高、体重等）。
>     *   特征值近似服从正态分布的场景。
>     *   不适合处理离散数据，如文本分类中的词频数据。
> *   **示例应用**：
>     *   分类问题中，特征是连续变量的，如预测癌症的肿瘤大小。

#### 2. 多项式朴素贝叶斯（Multinomial Naive Bayes）

多项式朴素贝叶斯适用于**离散型数据，假设特征（如词频）符合多项式分布**。如词频或 **TF-IDF** 值。

**假设**：每个类别 C i C_i Ci​ 下的特征 x j x_j xj​ 服从多项式分布：  
P ( x ∣ C i ) = ( ∑ j = 1 d x j ) ! x 1 ! x 2 ! ⋯ x d ! ∏ j = 1 d P ( x j ∣ C i ) x j P(x | C_i) = \frac{\left( \sum_{j=1}^d x_j \right)!}{x_1! x_2! \cdots x_d!} \prod_{j=1}^d P(x_j | C_i)^{x_j} P(x∣Ci​)=x1​!x2​!⋯xd​!(∑j=1d​xj​)!​j=1∏d​P(xj​∣Ci​)xj​  
其中， d d d 是特征数量， x j x_j xj​ 是特征 j j j 的出现次数， P ( x j ∣ C i ) P(x_j | C_i) P(xj​∣Ci​) 是在类别 C i C_i Ci​ 下特征 j j j 出现的概率。

> *   **适用场景**：
>     *   特征值是非负整数（表示频数）。
>     *   文本分类，特征为词频或 **TF-IDF** 值。

> *   **示例应用**：
>     *   垃圾邮件分类，根据邮件中不同词的出现频率进行分类。
>     *   文档主题分类。

#### 3. 伯努利朴素贝叶斯（Bernoulli Naive Bayes）

伯努利朴素贝叶斯适用于**二元特征数据（如 0 和 1），假设特征服从伯努利分布。**，常用于特征值表示是否出现某个事件的场景。

假设：每个类别 C i C_i Ci​ 下的特征 x j x_j xj​ 服从伯努利分布：  
P ( x j ∣ C i ) = P ( x j = 1 ∣ C i ) x j ⋅ ( 1 − P ( x j = 1 ∣ C i ) ) 1 − x j P(x_j | C_i) = P(x_j = 1 | C_i)^{x_j} \cdot (1 - P(x_j = 1 | C_i))^{1 - x_j} P(xj​∣Ci​)=P(xj​=1∣Ci​)xj​⋅(1−P(xj​=1∣Ci​))1−xj​  
其中， x j x_j xj​ 为 0 或 1，表示特征 j j j 是否在样本中出现。

> *   **适用场景**：
>     *   特征为布尔值（0 或 1）表示的场景，如文本数据中的**词袋模型**（词是否出现）。
>     *   适用于稀疏数据，尤其是大量特征值为 0 的情况。
> *   **示例应用**：
>     *   文本分类中，每个特征表示某个词是否出现在文档中（即只关心是否出现，不关心出现的次数）。
>     *   文本情感分析，特征表示是否出现某些情感词汇。

#### 总结

*   **贝叶斯定理** 提供了一种**计算条件概率**的方法。
*   **朴素贝叶斯分类器** **假设特征之间相互独立**，尽管这一假设在实际中可能并不成立，但在很多应用中仍然表现良好。
*   **高斯朴素贝叶斯**：适合**连续值特征**，**假设**特征**服从正态分布**。
*   **多项式朴素贝叶斯**：适合**离散值特征**，**假设**特征**服从多项式分布**。特征表示频数，如词频数据。
*   **伯努利朴素贝叶斯**：适合**布尔值特征**，**假设**特征**服从伯努利分布**。特征表示某事件是否发生，如词袋模型的文本分类。

选择合适的朴素贝叶斯模型有助于提高分类效果，应根据数据特征和应用场景进行选择。

### 零概率问题

没有平滑时，这个概率可以表示为：

P ( x i ∣ C ) = count ( x i , C ) count (C) P(x_i | C) = \frac{\text{count}(x_i, C)}{\text{count}(C)} P(xi​∣C)=count(C)count(xi​,C)​

其中：

*   count ( x i , C ) \text{count}(x_i, C) count(xi​,C) 表示类别 C C C 下特征 x i x_i xi​ 出现的次数。
*   count (C) \text{count}(C) count(C) 表示类别 C C C 出现的总次数。

朴素贝叶斯中的零概率问题是指在计算后验概率时，如果**某个特征值在训练数据中没有出现**，则该**特征值的概率会被计算为 0**。由于贝叶斯公式中包含了特征值的概率乘积，只要一个特征值的概率为 0，那么**整体公式的结果也会为 0，导致预测结果不准确**。

#### 总结

*   **拉普拉斯平滑**：一种简单的平滑方法，通过在每个事件的频数上**加 1** 来避免零概率问题。适合简单场景，但在数据量较大时可能过于平滑。
*   **加权平滑**：**引入一个超参数控制特征的重要性或频率**分布，进行比例调整，适合在特征权重差异较大的情况下使用。
*   **Dirichlet 平滑**：一种基于 Dirichlet 分布的平滑方法，灵活度更高，通过给**每个特征引入超参数**对平滑程度进行调节，常用于复杂的文本模型、语言模型或多项式分布估计中。

#### 拉普拉斯平滑（Laplace Smoothing）

拉普拉斯平滑（也称为加一平滑）是一种解决概率估计中零概率问题的简单方法。拉普拉斯平滑通过**在每个事件的频数上加一个小的正数 (通常为 1)** 来避免零概率的出现。

公式为：  
![](https://i-blog.csdnimg.cn/direct/234ce29db0994e338be1c704a85965a5.png)其中：

*   count ( x i , C ) \text{count}(x_i, C) count(xi​,C) 表示类别 C C C 下特征 x i x_i xi​ 出现的次数。
*   count (C) \text{count}(C) count(C) 表示类别 C C C 出现的总次数。
*   | V V V | 是特征空间的大小 (即可能出现的所有特征的数量）。
*   加上 1 是为了保证所有特征的概率不为零

拉普拉斯平滑适用于解决朴素贝叶斯分类器中的零概率问题，这可能导致对频率较高的事件也进行了不必要的平滑，使得估计结果过于平滑。

#### 加权平滑（Weighted Smoothing）

可以**根据特征重要性**或频率分布**给予不同的权重**，从而在估计概率时更加准确。

公式为：  
P ( x i ∣ C ) = count ( x i , C ) + α count (C) + α ⋅ ∣ V ∣ P(x_i | C) = \frac{\text{count}(x_i, C) + \alpha}{\text{count}(C) + \alpha \cdot |V|} P(xi​∣C)=count(C)+α⋅∣V∣count(xi​,C)+α​  
其中：

*   count ( x i , C ) \text{count}(x_i, C) count(xi​,C) 表示类别 C C C 下特征 x i x_i xi​ 出现的次数。
*   count (C) \text{count}(C) count(C) 表示类别 C C C 出现的总次数。
*   | V V V | 是特征空间的大小 (即可能出现的所有特征的数量）。
*   α \alpha α 是**加权平滑的平滑参数**，用来控制平滑的强度。
    *   当 α = 1 \alpha = 1 α=1 时，公式退化为拉普拉斯平滑。
    *   如果 α > 1 \alpha > 1 α>1，则加大对未见事件的平滑强度。
    *   如果 α < 1 \alpha < 1 α<1，则对未见事件的平滑力度较小。

通过引入特征权重 α ，根据特征的重要性或频率分布进行比例调整。需要在平滑过程中考虑特征间差异的情况，调整 α 。

#### 狄利克雷平滑（Dirichlet Smoothing）

Dirichlet 平滑是一种更加灵活的平滑方法，它通过**引入超参数对每个特征的平滑程度进行调整**。相比拉普拉斯平滑，Dirichlet 平滑能够根据数据特点选择不同的平滑强度。

公式为：  
P ( x i ∣ C ) = count ( x i , C ) + α i count (C) + ∑ i = 1 ∣ V ∣ α i P(x_i | C) = \frac{\text{count}(x_i, C) + \alpha_i}{\text{count}(C) + \sum_{i=1}^{|V|} \alpha_i} P(xi​∣C)=count(C)+∑i=1∣V∣​αi​count(xi​,C)+αi​​  
其中：

*   count ( x i , C ) \text{count}(x_i, C) count(xi​,C) 表示类别 C C C 下特征 x i x_i xi​ 出现的次数。
*   count (C) \text{count}(C) count(C) 表示类别 C C C 出现的总次数。
*   | V V V | 是特征空间的大小 (即可能出现的所有特征的数量）。
*   α i \alpha_i αi​ 是每个特征 x i x_i xi​ 的平滑参数，不同的特征可以有不同的平滑强度。
*   当 α i \alpha_i αi​ 相等且为 1 时，Dirichlet 平滑退化为拉普拉斯平滑。

为每个类别分配不同的平滑参数，更加灵活。 计算较复杂，但在处理复杂的数据分布时更具优势。

![](https://i-blog.csdnimg.cn/direct/cbe7db0d3bf841a6914e5acafdfa4d9c.png)

决策树（Decision Tree）
------------------

### 决策树（Decision Tree）概述

决策树是一种**基于树形结构的机器学习算法，广泛应用于分类和回归任务中**。它通过一系列的规则**将数据集划分为不同的子集**，从而进行分类或预测。决策树算法直观、易于解释，并且能够处理复杂的特征交互。

### 基本概念

*   **节点（Node）**：
    *   **根节点（Root Node）**：树的起始节点，表示整个**数据集**。
    *   **内部节点（Internal Node）**：表示数据集的划分条件，包含**特征和阈值**。
    *   **叶节点（Leaf Node）**：表示分类或回归的最终结果，包含**类别标签或连续值**。
*   **分支（Branch）——决策规则**：从一个节点到另一个节点的路径。
*   **路径（Path）——决策过程**：从根节点到叶节点的序列。
*   **深度（Depth）——决策树的复杂度**：从根节点到最深叶节点的最长路径长度。

### 任务类型

决策树既可以用于**分类任务**，也可以用于**回归任务**。

#### 分类任务

在分类任务中，决策树用于**将数据划分到不同的离散类别中**。目标是通过一系列条件判断，将数据划分为不同类别，并最终在叶节点上输出类别标签。

*   **常用算法（不同的划分特征的标准）**：
    
    *   **ID3**：使用**信息增益**来选择划分特征。
    *   **C4.5**：使用**信息增益比**来选择划分特征，并支持连续特征处理。
    *   **CART（分类树）**：使用**基尼系数 (Gini Index)** 来选择最优划分特征。
*   **应用场景**：
    
    *   电子邮件分类（垃圾邮件识别）。
    *   图像识别（识别不同的物体类别）。
    *   医疗诊断（预测病人的健康状况类别）。

#### 回归任务

在回归任务中，决策树**用于预测连续值**。目标是通过一系列的分裂操作，将数据划分成不同的区间，并在每个叶节点上输出一个数值（通常是该节点中所有样本的均值）。

*   **常用算法**：
    
    *   **CART（回归树）**：使用 ** 最小化均方误差 (Mean Squared Error, MSE)** 或其他度量标准来选择最优划分特征。
*   **应用场景**：
    
    *   房价预测（预测某个地区的房屋价格）。
    *   股票市场预测（预测股票的未来价格）。
    *   气象预测（预测某个地点的温度或降雨量）。

#### 分类和回归中的差异

分类树（Classification Tree）：

*   输出的是离散类别标签。
*   每个叶节点表示一个类别。
*   划分标准基于分类纯度（如信息增益、基尼系数）。

回归树（Regression Tree）：

*   输出的是连续数值。
*   每个叶节点表示一个数值（如节点样本的均值）。
*   划分标准基于回归误差（如均方误差）。

### 决策树算法的具体实现

#### 比较总结

<table><thead><tr><th><strong>算法</strong></th><th><strong>划分标准</strong></th><th><strong>支持连续特征</strong></th><th><strong>处理缺失值</strong></th><th><strong>树结构</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>ID3</strong></td><td>信息增益</td><td>否</td><td>否</td><td>多叉树</td><td>实现简单，适合小规模数据</td><td>偏向于选择取值多的特征，不能处理连续变量</td><td>小规模、离散特征数据集</td></tr><tr><td><strong>C4.5</strong></td><td>信息增益比</td><td>是</td><td>是</td><td>多叉树</td><td>支持连续特征，能处理缺失值</td><td>计算复杂度高，生成树较大</td><td>大规模数据，有连续特征和缺失值的数据</td></tr><tr><td><strong>CART</strong></td><td>基尼系数</td><td>是</td><td>否</td><td>二叉树</td><td>适用于分类和回归问题，剪枝方便</td><td>对噪声数据敏感，容易过拟合</td><td>分类、回归任务，要求生成二叉树时</td></tr></tbody></table>

*   **ID3** 适合**小规模**的、**离散**特征的数据集，但**不适合**处理**连续特征和缺失值**。
*   **C4.5** 是 ID3 的改进版本，**能处理连续特征、缺失值**，适合处理复杂的大规模数据集。
*   **CART** 能同时用于分类和回归任务，生成简洁的**二叉树结构**，但对噪声敏感，适合需要生成二叉树结构的应用场景。

#### ID3（Iterative Dichotomiser 3）

##### 原理

*   ID3 **通过信息增益（Information Gain）来选择划分特征**，ID3 选择**信息增益最大的特征**进行划分。信息增益表示划分数据集后信息熵的减少程度，熵越小，数据纯度越高。主要用于**分类任务**。

##### 主要特点

*   **划分准则**：使用**信息增益**，优先选择信息增益最大的特征进行分裂。
*   **适用数据类型**：ID3 主要适用于**离散特征**，不支持连续特征的处理。
*   **剪枝**：ID3 本身**没有提供剪枝**机制，容易出现过拟合问题。

##### 信息熵（Entropy）

信息熵用于**衡量数据集的（纯度或）混乱程度**。**信息熵越高，数据越混乱**；信息熵越低，数据越纯。  
  
对于数据集 ( D D D )，它的熵定义为：  
H (D) = − ∑ i = 1 m p i log ⁡ 2 ( p i ) H(D) = - \sum_{i=1}^m p_i \log_2(p_i) H(D)=−i=1∑m​pi​log2​(pi​)  
其中：

*   m m m 是类别的总数。
*   p i p_i pi​ 是数据集中属于第 i i i 类的样本所占的比例。

##### 信息增益（Information Gain）

表示某一特征 A A A 将数据集 D D D **划分后的纯度提升程度**。ID3 选择**信息增益最大**的特征进行划分。信息增益的公式为：  
信息增益 = H (D) − ∑ v = 1 V ∣ D v ∣ ∣ D ∣ H ( D v ) \text{信息增益} = H(D) - \sum_{v=1}^V \frac{|D_v|}{|D|} H(D_v) 信息增益 =H(D)−v=1∑V​∣D∣∣Dv​∣​H(Dv​)  
其中：

*   H (D) H(D) H(D) 是数据集 D D D 的信息熵。
*   V V V 是特征 A A A 的可能取值数。
*   D v D_v Dv​ 是根据特征 A A A 的取值 v v v 分割得到的子集。
*   ∣ D v ∣ / ∣ D ∣ |D_v| / |D| ∣Dv​∣/∣D∣ 表示取值 v v v 的样本在数据集 D D D 中的比例。
*   H ( D v ) H(D_v) H(Dv​) 是子集 D v D_v Dv​ 的熵。

##### 算法流程

1.  计算当前所有特征对数据集的**信息增益**。
2.  选择信息增益最大的特征作为当前节点的划分标准。
3.  根据该特征的不同取值划分数据集，并在每个子集上递归地重复步骤 1 和步骤 2。
4.  当所有特征都被使用，或所有样本都属于同一类别时，停止划分。

##### 优点

*   **简单易懂**：ID3 的核心思想和实现相对简单，能够快速生成决策树。
*   **高效**：ID3 计算信息增益后即可快速进行划分。

##### 缺点

*   **倾向于选择取值多的特征**：ID3 更倾向于选择取值多的特征进行划分，可能导致过拟合。
*   **只能处理离散特征**：ID3 不能处理连续特征。
*   **对缺失值不敏感**：ID3 不能有效处理数据中的缺失值。

#### C4.5

##### 原理

选择**信息增益比**（**信息增益与分裂信息的比值**）**最大**的特征进行划分，用于**平衡特征数量和划分质量之间的关系**。通过引入 “分裂信息”（Split Information）来**惩罚分裂数目较多的特征**。**支持连续特征，处理缺失值**，加入**剪枝**。

##### 主要特点

*   **划分准则**：使用**信息增益比**，避免 ID3 中对多值特征的偏向。
*   **适用数据类型**：支持**离散和连续特征**。
*   **剪枝**：C4.5 支持**错误率估计的后剪枝**策略，防止过拟合。

##### 信息增益比（Information Gain Ratio）

信息增益比是信息增益与特征的 “固有信息” 之比。特征的固有信息衡量的是特征取值的均匀性。信息增益比的公式为：

信息增益比 = 信息增益 固有信息 \text{信息增益比} = \frac{\text{信息增益}}{\text{固有信息}} 信息增益比 = 固有信息信息增益​

其中，**信息增益的公式与 ID3 相同**。

##### 固有信息（Intrinsic Information）

固有信息**衡量**的是**特征 A A A 的取值分布**，它的计算公式为：

固有信息 = − ∑ v = 1 V ∣ D v ∣ ∣ D ∣ log ⁡ 2 ( ∣ D v ∣ ∣ D ∣ ) \text{固有信息} = - \sum_{v=1}^V \frac{|D_v|}{|D|} \log_2 \left( \frac{|D_v|}{|D|} \right) 固有信息 =−v=1∑V​∣D∣∣Dv​∣​log2​(∣D∣∣Dv​∣​)  
其中：

*   V V V 是特征 A A A 的可能取值数。
*   D v D_v Dv​ 是数据集 D D D 中特征 A A A 取值为 v v v 的子集。
*   ∣ D v ∣ / ∣ D ∣ |D_v| / |D| ∣Dv​∣/∣D∣ 表示取值 v v v 的样本在数据集 D D D 中的比例。

在 C4.5 算法中，处理连续型变量和缺失值的方法具体如下：

##### 处理连续型变量

当特征是**连续型变量**时，C4.5 算法**将其转化为一个二值问题**（例如，**小于某个阈值和大于等于该阈值**），以便将连续变量用于决策树的分裂。

**步骤**：

1.  **生成候选划分点**：将**连续特征值按升序排列**，计算每个相邻值的中点作为候选划分点。例如，如果连续特征的两个相邻值为 x i x_i xi​ 和 x i + 1 x_{i+1} xi+1​，候选划分点为 t = x i + x i + 1 2 t = \frac{x_i + x_{i+1}}{2} t=2xi​+xi+1​​。
2.  **计算信息增益比**：对于每个候选划分点 (t)，将数据集**划分成两个子集**：
    *   子集 1：特征值 ≤ t \leq t ≤t 的样本。
    *   子集 2：特征值 > t > t >t 的样本。
3.  **选择最佳划分点**：计算所有候选划分点的**信息增益比**，选择信息增益比最大的划分点作为最终分裂点。这样可以有效地将连续变量转化为二值判断。

##### 处理缺失值

在 C4.5 算法中，对于特征值缺失的样本，算法不会简单地丢弃，而是利用**概率分布**填充缺失值，从而有效利用数据。

**步骤**：

1.  **计算样本权重**：在计算信息增益比时，**含缺失值的样本**按照其在整个数据集中的比例被赋予一个**权重**。这些缺失样本**将按比例分布到不同分支**。
2.  **按概率分配样本**：在分裂节点时，缺失特征的样本将依据分支上的样本比例进行分配。例如，如果一个特征缺失的样本在某节点有 70% 的概率被归入左子树，则会将 70% 的权重分配给左子树，30% 的权重分配给右子树。
3.  **分类时的缺失值处理**：在决策树生成后进行预测时，对于测试样本中缺失的特征，C4.5 也使用概率分布填充，使其根据现有特征值的分布推断分类。

##### 算法流程

1.  计算每个特征的**信息增益比**。
2.  选择信息**增益比最大的特征作为划分特征**。
3.  如果特征是**连续型变量**，将特征值划分为小于某个阈值和大于等于该阈值的两部分。
4.  **处理缺失值，使用概率分布填充**。
5.  递归地构建子树，直到满足停止条件。

##### 优点

*   **支持连续特征**：C4.5 通过引入阈值分割，能够处理连续型变量。
*   **减少过拟合倾向**：使用信息增益比来进行特征选择，避免了对取值多的特征的偏好。
*   **处理缺失值**：能够处理数据集中缺失值的问题。

> 算法流程中的：  
> 3. 如果特征是**连续型变量**，将特征值划分为小于某个阈值和大于等于该阈值的两部分。  
> 4. 处理缺失值，使用**概率分布填充**。

##### 缺点

*   **计算复杂度较高**：相比 ID3，C4.5 由于需要计算信息增益比、处理连续特征和缺失值，计算复杂度较高。
*   **容易产生较大的树**：C4.5 生成的树结构有时可能过大，需要进行剪枝以减少过拟合。

#### CART（Classification and Regression Tree）

##### 原理

CART（Classification and Regression Tree）算法可以用于**分类和回归**任务。CART 构造的是一棵**二叉树**。

1.  对于**分类**任务，选择**基尼指数最小**的特征作为划分特征。
2.  对于**回归**任务，选择**均方误差最小**的特征进行分裂。

##### 主要特点

*   **划分准则**：
    *   **分类任务**：使用**基尼指数**作为划分准则。
    *   **回归任务**：使用**均方误差**作为划分准则。
*   **适用数据类型**：支持**离散和连续特征**。
*   **剪枝**：CART 支持**后剪枝**策略，通过成本复杂度剪枝来防止过拟合。

##### 分类任务基尼指数（Gini Index）

基尼指数用于**衡量数据集的纯度**。基尼**系数越小**，数据集的**纯度越高**。选择**基尼指数最小**的特征作为划分特征。

对于数据集 D D D，其基尼指数定义为：  
基尼指数 = 1 − ∑ i = 1 m p i 2 \text{基尼指数} = 1 - \sum_{i=1}^m p_i^2 基尼指数 =1−i=1∑m​pi2​  
其中：

*   m m m 是类别的总数。
*   p i p_i pi​ 是数据集中属于第 $ i$ 类的样本所占的比例。

当一个特征 A A A 有多个可能的取值时，特征 A A A 对数据集 D D D 的基尼指数可以表示为：

Gini ( D , A ) = ∑ v = 1 V ∣ D v ∣ ∣ D ∣ Gini ( D v ) \text{Gini}(D, A) = \sum_{v=1}^V \frac{|D_v|}{|D|} \text{Gini}(D_v) Gini(D,A)=v=1∑V​∣D∣∣Dv​∣​Gini(Dv​)

其中：

*   V V V 是特征 A A A 的取值个数。
*   D v D_v Dv​ 是根据特征 A A A 的取值 v v v 划分得到的子集。
*   Gini ( D v ) \text{Gini}(D_v) Gini(Dv​) 是子集 D v D_v Dv​ 的基尼指数。

##### 回归任务均方误差（Mean Squared Error, MSE）

对于回归任务，CART 算法**选择均方误差（MSE）最小**的特征进行分裂。均方误差衡量的是预测值和实际值之间的平均平方差。对于数据集 D D D ，均方误差定义为：  
MSE = 1 ∣ D ∣ ∑ i = 1 ∣ D ∣ ( y i − y ^ ) 2 \text{MSE} = \frac{1}{|D|} \sum_{i=1}^{|D|} (y_i - \hat{y})^2 MSE=∣D∣1​i=1∑∣D∣​(yi​−y^​)2  
其中：

*   ∣ D ∣ |D| ∣D∣ 是数据集中样本的数量。
*   y i y_i yi​ 是第 i i i 个样本的真实值。
*   y ^ \hat{y} y^​ 是数据集 D D D 中所有样本的均值。

##### 分类树算法流程

1.  对每个特征，计算不同划分下的**基尼系数**。
2.  选择基尼系数最小的特征作为当前节点的划分特征。
3.  递归地构建二叉树。
4.  当达到停止条件（如节点样本数小于设定阈值）时，停止递归。

##### 回归树算法流程

1.  **遍历每个特征**：对于每个特征，尝试在数据集中的不同数值作为可能的分裂点。
    
2.  **计算分裂后的均方误差**：对于每个分裂点，计算其分裂后左右子集的加权均方误差（MSE），公式如下：  
    ![](https://i-blog.csdnimg.cn/direct/34e8d307f29e4d66a46c34774bd2a998.png)
    
3.  **选择最优分裂点**：选择使得分裂后均方误差最小的分裂点，将该特征和分裂点作为当前节点的分裂依据。
    
4.  **递归构建树**：对分裂后的左右子节点重复步骤 1-3，继续寻找最优分裂点，构建新的子节点。
    
5.  **停止条件**：当达到预设的停止条件时（例如节点样本数小于设定阈值或 MSE 降低不明显），停止递归分裂。此时，该节点成为一个叶节点，并赋予其目标值的平均值作为预测值。
    

##### 优点

*   **可处理分类和回归问题**：CART 不仅适用于分类任务，也可用于回归任务。
*   **生成二叉树结构**：树结构简单，每个节点最多有两个分支，便于实现和计算。
*   **易于剪枝**：CART 提供了剪枝机制，可以有效减少过拟合。

##### 缺点

*   **对噪声数据敏感**：CART 对于数据中的噪声较为敏感，容易生成较复杂的树结构。
*   **基尼系数局限性**：基尼系数在处理某些分类问题时效果不如信息增益或信息增益比。
*   **连续特征处理较复杂**：虽然 CART 可以处理连续特征，但需要遍历所有特征值进行划分，计算量较大。

### 决策树的过拟合和欠拟合

#### 解决欠拟合

欠拟合要增加模型复杂度：

1.  增加树的深度
2.  减少最小样本分裂数，让更多节点可以分裂
3.  减少最小叶子节点数，让树生长得更深

> 欠拟合通常是因为模型的复杂度不够，无法很好地拟合训练数据。应对欠拟合的方法通常是**增加模型复杂度**。包括：
> 
> *   **增加树的深度（max_depth）**：通过增加决策树的深度，可以让模型拟合更多的数据特征，从而减少欠拟合。
> *   **减少最小样本分裂数（min_samples_split）**：减少节点分裂所需的最小样本数，让更多节点可以分裂，使模型更复杂。
> *   **减少最小叶子节点数（min_samples_leaf）**：减少叶子节点的最小样本数，让树生长得更深、更复杂。

#### 解决过拟合

过拟合要增加模型复杂度：

1.  限制树的深度
2.  增加最小样本分裂数，限制树的生长
3.  增加最小叶子节点数，减少树的大小

> 过拟合是因为模型过于复杂，导致对训练数据的拟合过度。应对过拟合的方法通常是**减少模型复杂度**。包括：
> 
> *   **限制树的深度（max_depth）**：限制树的最大深度可以防止树过于复杂，有助于防止过拟合。
> *   **增加最小样本分裂数（min_samples_split）**：通过增加节点分裂所需的最小样本数，可以限制树的生长，使树不至于过度拟合训练数据。
> *   **增加最小叶子节点数（min_samples_leaf）**：增加叶子节点的最小样本数可以减少树的复杂度，防止过拟合。
> *   **使用剪枝技术（如代价复杂度剪枝）**：剪枝是控制过拟合的重要技术之一，通过减少树的大小来防止模型过度拟合。

### 剪枝（Pruning）

剪枝是决策树中用来**防止过拟合**的一种技术。它通过**移除或合并一些不必要的节点来减少树的复杂度**，从而提高模型的泛化能力。剪枝可以分为两种方式：

#### 预剪枝（Pre-pruning）

*   **原理**：在**构建决策树的过程中**，提前停止树的生长，以避免树过于复杂。
*   **方法**：
    1.  **设置最大深度**：限制决策树的最大深度，防止树过深导致过拟合。
    2.  **设置最小样本数**：要求每个节点至少包含一定数量的样本，如果样本数不足则停止划分。
    3.  **设置最小信息增益**：如果划分后的信息增益小于某个阈值，则停止划分。
*   **优点**：节省计算资源，减少构建时间。
*   **缺点**：可能会提前停止构建，导致欠拟合。

#### 后剪枝（Post-pruning）

*   **原理**：**在决策树完全生长后**，通过评估树的各个子树的表现来剪去不必要的分支，从而简化模型。
*   **方法**：
    1.  **子树替换（Subtree Replacement）**：**用一个叶节点替换一个子树**，直到错误率最低。
    2.  **子树提升（Subtree Raising）**：**将子节点提升到父节点位置，删除不必要的中间节点**。
    3.  **成本复杂度剪枝（Cost Complexity Pruning）**：通过最小化模型复杂度和训练误差的加权和，**选择最优的子树**。
*   **优点**：能够更精确地控制模型复杂度，提高泛化能力。
*   **缺点**：计算量较大，剪枝过程复杂。

`注`：C4.5 和 CART 都使用了**后剪枝 post-pruning** 方法来防止决策树的过拟合。

##### C4.5 的错误率估计剪枝操作

C4.5 在剪枝过程中采用**错误率估计**（Error-based Pruning）来决定是否剪枝。它通过**对每个分支的误分类情况估计**，如果剪去子树后能减少误分类率，就将该子树替换为叶节点。

> *   **操作步骤**：
>     1.  对**每个叶节点和子树进行错误率估计**。C4.5 引入了拉普拉斯平滑估计来计算每个节点的错误率。
>     2.  计算子树的错误率，如果子树的错误率比该子树替换为叶节点后的错误率高，则将该子树剪除，将其变为叶节点。
>     3.  重复该过程，直到所有需要剪枝的子树都被剪除。

*   **优点**：这种剪枝策略考虑了训练数据中的随机性，可以有效防止过拟合。
*   **局限性**：由于需要计算每个节点的错误率，并进行多次迭代计算，剪枝过程的计算开销较大。

##### CART 的成本复杂度剪枝操作

**CART** 使用的是**成本复杂度剪枝（Cost Complexity Pruning）**，也称为**最小代价复杂度剪枝**。基于子树的**错误率和模型复杂度的权衡**。计算每个子树的错误率和复杂度，复杂度用子树中节点的数量来衡量。CART 会逐步**剪掉那些增加了模型复杂度但并没有显著降低错误率的子树**。

*   **原理**：成本复杂度剪枝通过**平衡模型的复杂度**和**预测误差**来选择最佳子树。它会给每个子树分配一个代价复杂度得分（Cost Complexity Score），该得分考虑了模型的复杂度和训练误差之和。
    
*   **代价复杂度（Cost Complexity）**：  
    ![](https://i-blog.csdnimg.cn/direct/b666dbf6d7144eaeb57a7e046cc12cd0.png)
    

> *   **操作步骤**：
>     1.  计算当前决策树每个子树的代价复杂度得分 (R_\alpha(T))。
>     2.  找到降低代价复杂度得分最多的子树，并将其剪除，合并为一个叶节点。
>     3.  重复上述步骤，逐步剪枝，直到得到最优子树为止。
>     4.  使用交叉验证等方法选择最优的 (alpha) 值，确定最终的剪枝结果。

*   **优点**：能够在模型复杂度和预测性能之间找到最优平衡点，较好地控制了模型的复杂度。
*   **局限性**：代价复杂度参数的选择对模型性能影响较大，需要进行交叉验证等方法来优化。

#### 总结

*   **C4.5** 主要用于分类任务，并使用**错误率估计的后剪枝**策略进行剪枝，以防止过拟合。它通过比较子树和叶节点的错误率来决定是否剪枝。
*   **CART** 可用于分类和回归任务，采用**成本复杂度剪枝**方法，通过平衡模型复杂度和训练误差选择最优子树，确保模型具有良好的泛化能力。

因此，C4.5 和 CART 在剪枝策略上各有特点，分别针对不同的任务和模型复杂度进行了优化。

![](https://i-blog.csdnimg.cn/direct/b0d2002b592f458fa23a3772e548eefa.png)

集成学习（Ensemble Learning）概述
-------------------------

集成学习是一种**通过组合多个模型（通常是弱模型）来提升整体预测性能的技术**，主要分为 **Bagging** 和 **Boosting** 两类方法。Bagging 和 Boosting 是构建强大的集成模型的基础，并衍生出了多种经典的算法，如随机森林、AdaBoost、Gradient Boosting、XGBoost 和 GBDT。

### Bagging 和 Boosting 的对比

<table><thead><tr><th><strong>属性</strong></th><th><strong>Bagging</strong></th><th><strong>Boosting</strong></th></tr></thead><tbody><tr><td><strong>模型训练方式</strong></td><td><strong>并行</strong>训练多个模型</td><td><strong>串行</strong>训练多个模型</td></tr><tr><td><strong>每次训练的数据集</strong></td><td>每次从原始数据集进行<strong>有放回随机采样</strong>生成不同的<strong>子集</strong></td><td>每次使用<strong>相同的数据集</strong>，但样本的权重会随错误分类情况调整</td></tr><tr><td><strong>关注样本方式</strong></td><td>每个模型使用<strong>相同的样本权重</strong></td><td><strong>不同的权重</strong>，后续模型重点关注前一模型的错误</td></tr><tr><td><strong>结果集成方式</strong></td><td>平均（回归）或投票（分类）</td><td>加权组合模型</td></tr><tr><td><strong>主要优点</strong></td><td>降低方差，<strong>减少过拟合</strong></td><td>降低偏差，提高模型精度，<strong>减少欠拟合</strong></td></tr><tr><td><strong>主要缺点</strong></td><td>对偏差问题无明显改善</td><td>对噪声敏感，训练时间长</td></tr><tr><td><strong>代表算法</strong></td><td>随机森林</td><td>AdaBoost、Gradient Boosting</td></tr></tbody></table>

*   **Bagging**：通过并行训练多个模型，降低模型的方差，更适合**高方差模型**（减轻过拟合），如随机森林是其经典应用。
*   **Boosting**：通过串行训练多个模型，逐步提升模型性能，更适合提升**高偏差模型**（减轻欠拟合），经典算法包括 AdaBoost 和 Gradient Boosting。

> 高方差是过拟合，高偏差是欠拟合

Bagging 算法
----------

### 什么是 Bagging？

Bagging（Bootstrap Aggregating）是一种**并行集成学习方法**，它通过**在训练集中多次随机采样（有放回的抽样）生成多个不同的子集，并在每个子集上训练模型，最终通过平均（回归）或投票（分类）得到集成模型的预测结果**。

### Bagging 的主要特点

*   **并行训练**：每个模型是独立训练的，因此可以并行计算。
*   **有放回的随机采样**。
*   **减小方差，降低过拟合**：通过组合多个模型，可以有效降低模型的方差，提高稳定性。
*   **不易过拟合，容易欠拟合**：对于不稳定的模型（如决策树），Bagging 能有效减少过拟合的风险。

### 常用的 Bagging 算法

#### 随机森林（Random Forest）

*   随机森林是在 Bagging 的基础上，对每个子模型（决策树）进一步**随机选择特征**进行训练。它通过**引入特征选择的随机性，进一步减少了模型的方差，提高了模型的泛化能力**。
*   **工作原理**：
    1.  从训练集中随机**有放回地抽样**，生成多个子集。
    2.  对**每个子集训练**一个决策树模型。
    3.  在每棵树的节点划分时，**随机选择部分特征**进行划分。
    4.  对于**分类任务**，通过所有树的**投票结果**决定最终的类别；对于**回归任务**，通过**所有树的平均值**决定最终的预测值。

Boosting 算法
-----------

### 什么是 Boosting？

Boosting 是一种**串行集成**学习方法，它通过**逐步训练一系列弱模型，每个模型都试图纠正前一个模型的错误预测**。最终的**集成模型是所有弱模型的加权和**。

### Boosting 的主要特点

*   **串行训练**：模型是依次训练的，后一个模型依赖于前一个模型的结果。
*   **减小偏差，减轻欠拟合**：通过加权训练，Boosting 能够逐步减小模型的偏差。
*   **易于过拟合**：由于模型不断地优化错误样本，容易在训练数据上表现过好，需要使用正则化等技术来防止过拟合。

### 常用的 Boosting 算法

<table><thead><tr><th><strong>算法</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>AdaBoost</strong></td><td>通过<strong>调整样本权重</strong>，训练多个弱分类器，并<strong>加权组合</strong>。</td><td>简单易实现，适合分类任务。</td><td><strong>对噪声敏感</strong>，容易过拟合，需控制弱分类器数量。</td><td>分类任务，如垃圾邮件分类等。</td></tr><tr><td><strong>GB</strong></td><td><strong>泛指梯度提升框架</strong>，通过<strong>梯度下降拟合残差</strong>优化模型。</td><td>提升模型精度，减少偏差，适合分类和回归任务。</td><td>训练时间较长，容易过拟合。</td><td>分类和回归，非线性数据场景。</td></tr><tr><td><strong>GBDT</strong></td><td><strong>基于决策树的梯度提升方法</strong>，通过拟合残差优化模型。</td><td>强大回归能力，处理复杂非线性关系。</td><td>训练时间长，需调参（树的数量、学习率等）。</td><td>分类和回归，复杂特征场景。</td></tr><tr><td><strong>XGBoost</strong></td><td><strong>GBDT 的增强版</strong>，引入<strong>正则化、并行化和缺失值处理</strong>等优化。</td><td>训练速度快，性能好，适用于大规模数据集。</td><td>模型复杂，超参数调优困难。</td><td>大规模数据下的分类和回归任务。</td></tr><tr><td><strong>LightGBM</strong></td><td><strong>GBDT 的优化版</strong>，基于<strong>直方图算法</strong>和<strong>叶子节点生长策略</strong>。</td><td>训练速度极快，内存占用少，适合大数据集和高维数据</td><td><strong>对小数据集不适合</strong>，Leaf-wise 策略可能导致过拟合，需调参。</td><td>大规模数据下的分类、回归和排序任务。</td></tr></tbody></table>

*   **AdaBoost**：适合**分类任务**，通过**加权样本聚焦错分类**，但容易过拟合。
*   **GB**：**梯度下降框架**，适合分类和回归，但训练慢。
*   **GBDT**：是 **GB 框架的一个具体实现**，专用**决策树做弱学习器**，处理复杂关系，训练时间长。
*   **XGBoost**：GBDT 的增强版，速度快，适合大规模数据，但需复杂调参。
*   **LightGBM**：基于 GBDT 的改进算法，通过直方图方法加速训练，适合大规模数据和高维特征场景，具有极快的训练速度，但容易过拟合，需调参。

#### AdaBoost（Adaptive Boosting）

*   **原理**： **AdaBoost** 是最早的 Boosting 算法之一，最常用于**二分类问题**。AdaBoost 通过迭代训练**弱分类器**（通常是**决策树桩**），每一轮迭代中，AdaBoost 会**调整样本的权重**，**增加错误分类样本的权重**，使得下一轮的弱分类器能够更关注那些难以分类的样本。
    
*   > **决策树桩**是一种极其简单的决策树，它只有一个划分节点和两个叶节点。也就是说，决策树桩仅能基于单一特征进行一次划分，将数据集分为两个部分。
    
*   **主要特点**：  
    **权重调整**：每轮训练后，**增加误分类样本的权重**，使下一轮分类器更注重这些难分类的样本。  
    **组合方式**：将每个弱分类器的预测结果以**加权方式组合**起来，得到最终的预测结果。  
    **优点**：容易实现，能够有效提高分类精度。  
    **缺点**：对噪声数据比较敏感，因为噪声数据会反复加重权重，容易过拟合，需要控制弱分类器的数量。
    
*   **算法步骤**：
    
    1.  **初始化**样本权重，使每个样本的**权重相等**。
    2.  训练一个弱分类器，计算该分类器的错误率。
    3.  **更新样本权重**，使**错误分类**的样本**权重增加**，正确分类的样本权重减少。
    4.  **计算该分类器的权重**（与错误率相关），并将其**加入到最终模型**中。
    5.  重复上述步骤，直到达到预定的弱分类器数量或错误率阈值。

#### GB（Gradient Boosting）

*   **原理**： **Gradient Boosting** 是一种通过**优化损失函数**的 Boosting 方法。与 **AdaBoost 直接调整样本权重不同**，**Gradient Boosting** 是通过**拟合当前模型的残差**（即模型预测与真实值的差异）来训练下一个弱分类器的。
*   **主要特点**：
    *   **残差拟合**：每一步都会**训练**一个**新的弱分类器**，**拟合之前模型的残差**，逐步减少模型的预测误差。
    *   **损失函数最小化**：Gradient Boosting 的目标是**最小化损失函数**（如平方误差、交叉熵），每一步的优化都是**沿着梯度下降的方向**。
    *   **优点**：在回归和分类问题中效果非常好，能灵活选择损失函数。
    *   **缺点**：训练时间较长，对超参数比较敏感，容易过拟合。
*   **算法步骤**：
    1.  **初始化模型**: 一开始我们建立一个简单的模型，比如使用训练数据集的均值作为初始预测值。
    2.  **计算残差**: 在每一轮迭代中，我们**先计算现有模型的残差**，也就是模型当前预测和实际值之间的差距。
    3.  **拟合新树**: 然后，我们**训练一棵新的决策树**来**拟合这些残差**，这棵树的目标是减少这些残差。
    4.  **更新模型**: 新的树被加入到模型中，**模型更新**为**现有模型加上新树**的预测结果。
    5.  **重复训练**: 上述步骤重复多次，直到达到预设的迭代次数或预设的停止条件，比如残差减少到某个水平。

> 目标是将模型的预测值 F m (x) F_m(x) Fm​(x) 尽可能接近真实值 y y y 。假设**初始模型 F 0 (x) F_0(x) F0​(x) 是所有样本的均值**。后续每一轮**迭代**中：
> 
> 1.  **计算残差或负梯度**：在第 m m m 轮，我们计算残差 r m = y − F m − 1 (x) r_m = y - F_{m-1}(x) rm​=y−Fm−1​(x)。
> 2.  **拟合残差**：训练一个弱学习器 (例如决策树) h m (x) h_m(x) hm​(x) 来拟合残差，使得 h m (x) h_m(x) hm​(x) 尽量接近 r m r_m rm​。
> 3.  **更新模型**：更新当前模型 F m (x) F_m(x) Fm​(x) 的预测为：  
>     F m (x) = F m − 1 ( x ) + η ⋅ h m ( x ) F_m(x) = F_{m-1}(x) + \eta \cdot h_m(x) Fm​(x)=Fm−1​(x)+η⋅hm​(x)  
>     这样一来，新的预测结果 F m (x) F_m(x) Fm​(x) 就更接近真实值 y y y。  
>     **η \eta η**：步长或学习率（learning rate）。它是一个超参数，用来控制每一轮的调整幅度。较小的学习率可以让模型更加稳定，但需要更多的迭代次数。

#### GBDT（Gradient Boosting Decision Tree）

*   **原理**：**GBDT**（梯度提升决策树，Gradient Boosting Decision Tree）是一种基于 **Gradient Boosting（梯度提升）** 的集成学习方法，它使用 **决策树** 作为基本的弱学习器。在每一轮迭代中，GBDT 通过**拟合当前模型的残差**，逐步减少模型的误差，使得最终模型能够实现更好的预测效果。
    
*   主要特点：
    
    *   **弱学习器**：GBDT 中的弱学习器是**决策树**，通常是深度较小的 CART 决策树（即二叉决策树）。
    *   **损失函数最小化**：GBDT 通过最小化损失函数（如均方误差、交叉熵等）来逐步提高模型性能。在每一轮迭代中，GBDT 训练新的决策树来拟合前一轮模型的残差。
    *   **灵活性**：GBDT 可以使用不同的损失函数（如回归任务中的平方误差、分类任务中的对数损失），具有很强的适应性。
    *   **迭代过程**：每一轮训练一个新的决策树来拟合当前模型的残差，通过逐步减小残差来优化整体模型。
    *   **加权组合**：GBDT 最终的预测结果是多个决策树加权输出的组合。
*   **算法步骤**：
    
    1.  **初始化**模型为一个常数模型，通常为所有训练样本目标值的均值。
    2.  计算当前模型的**残差**（即预测值与真实值的差）。
    3.  训练**一棵新的决策树**来拟合这些残差。
    4.  将**新的树加入到模型**中，并更新模型的预测值。
    5.  重复上述步骤，直到达到预定的树的数量或模型收敛。

##### GB 和 GBDT 的关系

> **Gradient Boosting（梯度提升）** 是一种框架，泛指一种**通过拟合残差来逐步提升模型性能的技术**。它可以使用不同的弱学习器（如线性回归、决策树等），而 **GBDT** 是一种特定的 Gradient Boosting 实现，**GBDT 选择的是决策树作为弱学习器**。
> 
> *   **Gradient Boosting** 是一个**广义上的提升框架**，核心思想是利用梯度下降法最小化损失函数。它可以结合**任何基学习器**（如线性回归、支持向量机等），但最常用的基学习器是决策树。
> *   **GBDT** 是 Gradient Boosting 框架下的一种具体实现，特指基于 **决策树** 的梯度提升模型。

##### 损失函数

GBDT 可以处理回归和分类问题，基于不同的损失函数：

###### 回归问题

对于**回归问题**，常用的损失函数是均方误差（MSE）：  
![](https://i-blog.csdnimg.cn/direct/fdf18a09dcde4c7fa3a0d72b7606f9ca.png)

###### 分类问题

对于**分类问题**（二分类），常用的损失函数是对数损失（Log Loss）：  
![](https://i-blog.csdnimg.cn/direct/e54604bef7a54077854d63fb3c7472b3.png)

#### XGBoost（Extreme Gradient Boosting）

*   **原理**：XGBoost 是 **GBDT 的改进版本**，采用了**正则化、并行化**、**自动处理缺失值**等优化技术。它引入了**二阶导数的损失函数优化**，可以加速收敛和提高模型精度。
    
*   **主要特点**：
    
    *   **正则化**：XGBoost 引入了 L1 和 L2 正则化项，以防止过拟合。
    *   **二阶导数优化**：对损失函数进行了二阶泰勒展开，使用损失的一阶导数（负梯度）和二阶导数（Hessian）来更新模型，使得 XGBoost 能**更精确地更新模型**，收敛速度更快。
    *   **分裂增益计算**：在每个节点的分裂过程中，XGBoost 通过计算分裂增益来**选择最优分裂点**。XGBoost 能有效选择最优分裂点，避免过度分裂。
    *   **并行化**：XGBoost 的并行化通过将特征分块后在不同线程上独立计算各特征的分裂增益，最终汇总以加速最佳分裂点的选择。
    *   **剪枝**：XGBoost 使用预剪枝策略来控制树的深度和复杂度。在训练过程中，如果增益低于设定阈值，则不进行分裂，从而避免生成多余的节点，进一步防止过拟合。
*   **算法步骤**：
    
    *   1.  与 Gradient Boosting 类似，XGBoost **通过拟合残差**进行迭代。
    *   2.  每一轮生成的新树通过拟合上一次模型的残差，减少整体的损失。
    *   3.  **增加了正则化项**，进一步优化了树结构的选择，避免模型复杂化导致过拟合。

##### 1. 目标函数及正则化项

XGBoost 的优化目标函数由两部分组成：损失函数（测量模型预测误差）和正则化项（控制模型复杂度）。XGBoost 的目标函数公式如下：

Obj = ∑ i = 1 N L ( y i , y ^ i ) + ∑ m = 1 M Ω ( f m ) \text{Obj} = \sum_{i=1}^N L(y_i, \hat{y}_i) + \sum_{m=1}^M \Omega(f_m) Obj=i=1∑N​L(yi​,y^​i​)+m=1∑M​Ω(fm​)

###### 损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​)

损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​) 测量每个样本的预测误差。例如，常用的损失函数有：

*   **均方误差 (MSE)**：用于回归问题，定义为 L ( y i , y ^ i ) = 1 2 ( y i − y ^ i ) 2 L(y_i, \hat{y}_i) = \frac{1}{2}(y_i - \hat{y}_i)^2 L(yi​,y^​i​)=21​(yi​−y^​i​)2。
*   **对数损失 (Log Loss)**：用于二分类问题。 L ( y , y ^ ) = − ( y ⋅ log ⁡ ( y ^ ) + ( 1 − y ) ⋅ log ⁡ ( 1 − y ^ ) ) L(y, \hat{y}) = - \left( y \cdot \log(\hat{y}) + (1 - y) \cdot \log(1 - \hat{y}) \right) L(y,y^​)=−(y⋅log(y^​)+(1−y)⋅log(1−y^​))

###### 正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​)

正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​) 用于控制模型复杂度，包含 L1 和 L2 正则化：

Ω ( f m ) = γ T + 1 2 λ ∑ j = 1 T w j 2 + α ∑ j = 1 T ∣ w j ∣ \Omega(f_m) = \gamma T + \frac{1}{2} \lambda \sum_{j=1}^T w_j^2 + \alpha \sum_{j=1}^T |w_j| Ω(fm​)=γT+21​λj=1∑T​wj2​+αj=1∑T​∣wj​∣

其中：

*   T T T 是树的叶节点数目。
*   w j w_j wj​ 是第 j j j 个叶节点的权重。
*   γ \gamma γ 控制叶节点的数量，较大的 γ \gamma γ 倾向于减少叶节点数量，使模型更简单。
*   λ \lambda λ 是 L2 正则化系数，控制叶节点权重的平方和，有助于平滑叶节点的权重。
*   α \alpha α 是 L1 正则化系数，控制叶节点权重的绝对值之和，促使部分权重趋向于零，从而构建更稀疏的模型。

以下是图片中的内容转换为文字：

##### 2. 二阶导数优化

为了提高训练效率，在实际优化中，XGBoost **对损失函数**进行了**二阶泰勒展开**，使用损失的一阶导数（负梯度）和二阶导数（Hessian）来更新模型：

Obj (m) ≈ ∑ i = 1 N [ g i f m ( x i ) + 1 2 h i f m ( x i ) 2 ] + Ω ( f m ) \text{Obj}^{(m)} \approx \sum_{i=1}^N \left[ g_i f_m(x_i) + \frac{1}{2} h_i f_m(x_i)^2 \right] + \Omega(f_m) Obj(m)≈i=1∑N​[gi​fm​(xi​)+21​hi​fm​(xi​)2]+Ω(fm​)

其中：

*   g i = ∂ L ( y i , y ^ i ) ∂ y ^ i g_i = \frac{\partial L(y_i, \hat{y}_i)}{\partial \hat{y}_i} gi​=∂y^​i​∂L(yi​,y^​i​)​ 是损失函数的一阶导数（梯度）。
*   h i = ∂ 2 L ( y i , y ^ i ) ∂ y ^ i 2 h_i = \frac{\partial^2 L(y_i, \hat{y}_i)}{\partial \hat{y}_i^2} hi​=∂y^​i2​∂2L(yi​,y^​i​)​ 是损失函数的二阶导数（Hessian）。

二阶导数使得 XGBoost 能更精确地更新模型，**收敛速度更快**。

##### 3. 分裂增益计算

在每个节点的分裂过程中，XGBoost 通过**计算分裂增益来选择最优分裂点**。增益公式如下：

Gain = 1 2 ( G L 2 H L + λ + G R 2 H R + λ − ( G L + G R ) 2 H L + H R + λ ) − γ \text{Gain} = \frac{1}{2} \left( \frac{G_L^2}{H_L + \lambda} + \frac{G_R^2}{H_R + \lambda} - \frac{(G_L + G_R)^2}{H_L + H_R + \lambda} \right) - \gamma Gain=21​(HL​+λGL2​​+HR​+λGR2​​−HL​+HR​+λ(GL​+GR​)2​)−γ

其中：

*   G L G_L GL​ 和 H L H_L HL​ 是左子节点的梯度和和二阶导数和。
*   G R G_R GR​ 和 H R H_R HR​ 是右子节点的梯度和和二阶导数和。
*   λ \lambda λ 是 L2 正则化系数。
*   γ \gamma γ 是控制叶节点数量的正则化超参数。

通过增益公式，XGBoost 能有效选择最优分裂点，避免过度分裂。

###### 分裂增益和 ID3 的信息增益的区别

> 1.  ID3：使用信息增益，基于信息论的熵来衡量节点纯度，通过最大化信息增益来选额分裂特征，适合分类问题中的树生成。
> 2.  XGBoost：使用基于梯度和二阶导数的分裂增益，直接通过梯度提升的方法最小化预测误差，适合用于梯度提升方法中。

**信息增益（Information Gain）**  
表示某一特征 A A A 将数据集 D D D **划分后的纯度提升程度**。ID3 选择**信息增益最大**的特征进行划分。信息增益的公式为：  
信息增益 = H (D) − ∑ v = 1 V ∣ D v ∣ ∣ D ∣ H ( D v ) \text{信息增益} = H(D) - \sum_{v=1}^V \frac{|D_v|}{|D|} H(D_v) 信息增益 =H(D)−v=1∑V​∣D∣∣Dv​∣​H(Dv​)  
其中：

*   H (D) H(D) H(D) 是数据集 D D D 的信息熵。
*   V V V 是特征 A A A 的可能取值数。
*   D v D_v Dv​ 是根据特征 A A A 的取值 v v v 分割得到的子集。
*   ∣ D v ∣ / ∣ D ∣ |D_v| / |D| ∣Dv​∣/∣D∣ 表示取值 v v v 的样本在数据集 D D D 中的比例。
*   H ( D v ) H(D_v) H(Dv​) 是子集 D v D_v Dv​ 的熵。

详细信息增益参考：[万字长文解读机器学习——决策树](https://lichuachua.blog.csdn.net/article/details/142437257#Information_Gain_97)

##### 4. 并行化

XGBoost 的并行不是 Tree 粒度的并行，XGBoost 也是一次迭代完才能进行下一次迭代的（第 t 次迭代的代价函数里包含了前面 t-1 次迭代的预测值）。XGBoost 的**并行是在特征粒度上的**。

1.  决策树的学习**最耗时**的一个步骤就是**对特征的值进行排序**（因为要确定最佳分割点），XGBoost 在训练之前，预先**对数据进行了排序，然后保存为 block 结构**。 后面的迭代中重复地使用这个结构，大大减小计算量。
2.  这个 **block 结构也使得并行成为了可能**，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。

#### LightGBM（Light Gradient Boosting Machine）

*   **原理**：LightGBM 是另一种基于 **GBDT（Gradient Boosting Decision Trees）** 的改进算法，采用了多种优化技术，如**基于直方图的分裂方法**、**叶子节点生长策略**，旨在提升效率并降低内存使用。LightGBM 特别擅长处理大规模数据集和高维度特征。
    
*   **主要特点**：
    
    *   **基于直方图的分裂方法**：LightGBM 通过**直方图算法**，将**连续特征分箱，从而大幅减少内存消耗和计算量**。
    *   **基于叶子生长策略的决策树**：LightGBM 使用**叶子生长策略，而不是深度优先策略**，每次**选择增益最大的叶子进行扩展**。这相比于传统的按深度生长方式能**更快地降低误差**。
    *   **支持类别特征**：LightGBM 能够**直接处理类别特征**，而**不需要对其进行独热编码**（one-hot encoding），从而提高了效率。
    *   **预剪枝**：LightGBM 使用了预剪枝策略来防止树的过度生长，降低过拟合的风险。
    *   **分布式学习**：支持分布式训练，适合在多台机器上并行处理超大规模数据集。
    *   **处理缺失值**：自动处理缺失数据，无需额外的预处理步骤。
*   **优点**：
    
    *   训练速度非常快，适合大规模数据集和高维数据。
    *   内存使用效率高，尤其在大规模数据集上的表现优秀。
    *   提供强大的分布式学习能力。
    *   针对类别特征的处理更高效。
*   **缺点**：
    
    *   **Leaf-wise** 增长策略有时**可能会导致过拟合**，需要通过调优控制模型复杂度。
    *   超参数较多，调优过程复杂。

##### 直方分裂算法（Histogram-based Splitting）

直方分裂算法是 LightGBM 的**核心优化之一**，它通过**将连续特征离散化成直方图**，显著减少了寻找最佳分裂点时的计算量，从而提升了训练速度。

**原理** ：  
在**传统的决策树构建中**，选择最佳分裂点需要遍历每个样本的特征值，计算各个分裂点的增益，计算量较大，尤其是在数据集和特征数较多时。

在 **LightGBM 中**，直方分裂算法**将连续特征值离散化为固定数量的桶**（bins），将特征值映射到这些离散桶中，**以降低计算复杂度**。

**操作流程**【详细待补充】：

*   **特征离散化**：将每个**连续特征**的取值范围划**分成 K 个桶**。假设将特征的值域划分为 K=256 个桶，那么每个特征值会被映射到其中的某一个桶中。
*   **构建直方图**：根据**桶中的数据**生成**直方图**。具体步骤为： 对每个分桶，累积样本数及其目标值的和（或梯度和）。 这样，每个桶会存储当前桶中所有样本的梯度和、样本数量，从而构成直方图。

选择最佳分裂点：在直方图上**遍历所有分桶**（**而不是逐个样本**），计算每个分桶的增益，找到最佳分裂点。

直方分裂公式假设我们当前节点包含 N 个样本，**目标是找到一个最优分裂点**，以使分裂后的左右子节点**增益最大化**。在计算增益时，使用直方图中的累积梯度和二阶梯度【同上面的 XGboost 中的**分裂增益**】：

Gain = 1 2 ( G L 2 H L + λ + G R 2 H R + λ − ( G L + G R ) 2 H L + H R + λ ) − γ \text{Gain} = \frac{1}{2} \left( \frac{G_L^2}{H_L + \lambda} + \frac{G_R^2}{H_R + \lambda} - \frac{(G_L + G_R)^2}{H_L + H_R + \lambda} \right) - \gamma Gain=21​(HL​+λGL2​​+HR​+λGR2​​−HL​+HR​+λ(GL​+GR​)2​)−γ

其中：

*   G L G_L GL​ 和 H L H_L HL​ 是左子节点的梯度和和二阶导数和。
*   G R G_R GR​ 和 H R H_R HR​ 是右子节点的梯度和和二阶导数和。
*   λ \lambda λ 是 L2 正则化系数。
*   γ \gamma γ 是控制叶节点数量的正则化超参数。

通过增益公式，**LightGBM 的直方分裂算法**能有效选择最优分裂点，避免过度分裂。

##### 基于叶子生长的策略（Leaf-wise Growth Strategy）

**原理** ：

传统的 **GBDT 和 XGBoost** 使用的是**层级生长策略**（Level-wise GrowthStrategy），即在每一层同时分裂所有节点，形成一棵尽可能平衡的树。然而，这种策略在大数据集上计算开销较大。

LightGBM，不是同时分裂整层节点。而是**采用叶子生长策略**（Leaf-wise Growth Strategy）**，**优先分裂增益最高的叶节点**，这样可以在树的相同深度下**更大限度地减少损失 **，使得模型具有更强的拟合能力。然而，叶子生长策略**可能会导致树结构不平衡**，尤其是在数据较为复杂时，可能会出现某些分支比其他分支深得多的情况，这可能**导致过拟合**。

**操作流程**

*   **初始化根节点**：在树的根节点计算损失，记录该节点的梯度和二阶梯度和。
*   **选择叶节点分裂**：对于每一轮分裂，**遍历所有当前叶节点，计算其分裂增益**。选择增益**最大**的叶节点进行分裂，而不是层级生长策略中对一层的所有节点进行分裂。 计算分裂增益：对于每个叶节点，分裂增益的计算公式同样为 XGboost 中的**分裂增益**：

Gain = 1 2 ( G L 2 H L + λ + G R 2 H R + λ − ( G L + G R ) 2 H L + H R + λ ) − γ \text{Gain} = \frac{1}{2} \left( \frac{G_L^2}{H_L + \lambda} + \frac{G_R^2}{H_R + \lambda} - \frac{(G_L + G_R)^2}{H_L + H_R + \lambda} \right) - \gamma Gain=21​(HL​+λGL2​​+HR​+λGR2​​−HL​+HR​+λ(GL​+GR​)2​)−γ

其中：

*   G L G_L GL​ 和 H L H_L HL​ 是左子节点的梯度和和二阶导数和。
*   G R G_R GR​ 和 H R H_R HR​ 是右子节点的梯度和和二阶导数和。
*   λ \lambda λ 是 L2 正则化系数。
*   γ \gamma γ 是控制叶节点数量的正则化超参数。

更新叶节点和分裂：分裂后，更新叶节点列表，将新生成的叶节点加入列表，并继续寻找增益最大的节点进行分裂。

**`注意`**：  
LightGBM 和 XGBoost 的**增益公式**是一样的，都是用梯度和二阶导数来计算每个分裂点的增益。但是由于树的生长策略不同，增益在两者中的作用方式有所区别。LightGBM 使用叶子生长策略，增益决定哪个叶节点优先分裂；XGBoost 使用层级生长策略，增益用于确定每层节点的分裂点。

### GBDT、XGBoost、LightGBM 迭代路径

更多的 Boosting 优化参考：  
[GBDT、XGBoost、LightGBM 迭代路径](https://lichuachua.blog.csdn.net/article/details/143320484)

Stacking 算法
-----------

**Stacking（堆叠集成）**是一种集成学习方法，利用**多个**不同模型（**基学习器**）生成预测结果，再用**一个**更高层次的模型（**元学习器**）来综合这些预测，从而提升整体预测性能。它灵活且有效，尤其在不同模型的预测结果存在互补性时表现尤佳。【其实类似**模型蒸馏的教师模型和学生模型**】

> 参考：[万字长文解读深度学习——训练（DeepSpeed、Accelerate）、优化（蒸馏、剪枝、量化）、部署细节](https://lichuachua.blog.csdn.net/article/details/142961933)

### 基本思想和流程

Stacking 的基本思想是**将多个模型（基学习器）的预测结果作为新特征**，再通过**一个**模型（通常称为**元学习器**）**来对这些特征进行综合**，生成最终预测。整体流程分为两层结构：

1.  **第一层（基学习器层）**：由**多个基学习器**组成。每个基学习器独立对训练数据进行训练，并生成预测结果。这些基学习器可以是同类型的不同参数模型，也可以是完全不同的模型。
2.  **第二层（元学习器层）**：基于第一层的预测结果，生成新的特征，再使用**一个元学习器**来**学习这些新特征**，从而做出最终预测。

### 实现步骤

#### 步骤 1：选择基学习器和元学习器

*   **基学习器**：选择多个不同的基学习器，通常**选用表现良好**的但**互补的模型**，比如决策树、支持向量机、逻辑回归、KNN、神经网络等。基学习器的多样性对于最终性能至关重要。
*   **元学习器**：通常**选择简单而具有强泛化能力的模型**，例如线性回归或逻辑回归，也可以使用更复杂的模型，如梯度提升决策树（GBDT）等。

#### 步骤 2：准备第一层输入数据（K 折交叉验证）

为了避免数据泄露（即避免让元学习器在训练时看到测试数据），我们通常对训练数据进行 K 折交叉验证来生成第一层的输出。

*   **训练过程**：
    *   将训练集划分为 K 折。
    *   针对每个基学习器，进行 K 次训练。每次在 K-1 个子集上训练，在剩余的 1 个子集上进行预测。
    *   将 K 次预测的结果合并，作为该基学习器在训练集上的输出。
    *   这样对每个基学习器得到一个与训练集相同大小的预测结果，作为新的特征（即第一层输出）。
*   **测试过程**：
    *   针对每个基学习器，使用全部训练数据进行训练，然后在测试集上进行预测。
    *   得到每个基学习器在测试集上的预测结果，将这些预测结果作为测试集的新特征。

#### 步骤 3：训练元学习器

*   使用基学习器的输出（即第一层的预测结果）作为新的特征，在训练集上训练元学习器。
*   元学习器可以是简单的线性模型，也可以是更复杂的模型，例如树模型。

#### 步骤 4：生成最终预测

*   在测试集上，基学习器生成的预测结果作为元学习器的输入，通过元学习器生成最终预测。

### 优点和缺点

#### 优点

*   **灵活性强**：可以组合不同类型的基学习器，充分利用它们的优势。
*   **性能提升明显**：基学习器的多样性带来的互补效果，可以显著提升预测性能。
*   **适应性强**：适合回归、分类任务，且能够处理高维特征。

#### 缺点

*   **计算成本高**：需要训练多个基学习器和元学习器，计算开销大，尤其在数据量较大时。
*   **调参复杂**：每个基学习器和元学习器都有独立的超参数，调优过程复杂。
*   **易过拟合**：如果基学习器和元学习器过于复杂，可能导致过拟合问题。

### 变体

1.  **Blending**：
    
    *   与 Stacking 类似，但 Blending 不使用交叉验证。
    *   将训练数据分为训练集和验证集。基学习器在训练集上训练，在验证集上生成预测结果，作为新的特征。
    *   优点是实现简单，缺点是验证集小，可能导致过拟合。
2.  **多层 Stacking**：
    
    *   可以扩展 Stacking 的层次结构，增加更多的层级（即多层元学习器）。
    *   例如：将第一层的输出作为第二层基学习器的输入，第二层的输出再输入到第三层元学习器，依此类推。
    *   多层 Stacking 可能会带来更好的性能，但调优难度和计算成本也会大幅增加。

### 实际实现中的注意事项

1.  **数据泄露问题**：确保元学习器的训练数据来自交叉验证的输出，以避免数据泄露问题。
2.  **基学习器的多样性**：选择具有互补性的基学习器，避免不同模型之间的高相关性。
3.  **正则化**：在元学习器上使用正则化（如 L2 正则化）可以防止过拟合。
4.  **特征缩放**：根据不同模型的需求，可以对输入数据进行特征缩放，以提升模型性能。
5.  **计算资源**：Stacking 需要多次训练模型，计算成本较高，因此在实际应用中要考虑资源情况。

### 总结

Stacking 是一种强大的集成学习方法，通过组合多个基学习器的预测结果，利用元学习器进一步学习这些结果，从而提升整体模型的性能。尽管 Stacking 计算复杂度高，但在实际应用中表现出色，尤其适合需要高精度预测的场景。

![](https://i-blog.csdnimg.cn/direct/d9332182c4ba410f8489269135844b37.png)

XGBoost 相对 GBDT 的改进
-------------------

**GBDT（Gradient Boosting Decision Tree，梯度提升决策树）** 是一种集成学习算法。GBDT 使用**梯度提升（Gradient Boosting）**的思想，每一棵**决策树**都是基于前一轮预测的**残差**（即误差）来训练的，从而逐步逼近真实值。

**XGBoost** 相对传统 GBDT 在原理和实现上进行了多项改进，使得它在计算效率、模型精度、内存管理和并行性等方面有显著提升。以下是 XGBoost 相对 GBDT 的关键改进：

<table><thead><tr><th>改进项</th><th>具体描述</th><th>优势</th></tr></thead><tbody><tr><td><strong>正则化项</strong></td><td>引入 ( L 1 L_1 L1​) 和 ( L 2 L_2 L2​) 正则化控制叶节点权重</td><td>防止过拟合，提高泛化能力</td></tr><tr><td><strong>二阶导数信息</strong></td><td>使用梯度和 Hessian 信息进行优化</td><td>提高收敛速度和精度</td></tr><tr><td><strong>列采样和行采样</strong></td><td>每棵树采样特征和样本</td><td>降低过拟合风险，提高泛化性</td></tr><tr><td><strong>并行化处理</strong></td><td>特征分片和直方分裂，支持 GPU 加速</td><td>提升训练速度</td></tr><tr><td><strong>缺失值处理</strong></td><td>自动选择缺失样本最佳分裂方向</td><td>处理缺失值和稀疏数据</td></tr><tr><td><strong>早停和学习率衰减</strong></td><td>监控验证集性能，学习率衰减控制每棵树贡献</td><td>降低过拟合和节省计算开销</td></tr><tr><td><strong>自定义目标和评估</strong></td><td>支持用户自定义目标函数和评估指标</td><td>提高适应性，满足不同场景需求</td></tr></tbody></table>

### 引入正则化项，防止过拟合

在 GBDT 中，每棵树的叶子节点权重没有额外的正则化控制，容易导致模型过拟合。**XGBoost** 在每棵树的目标函数中**引入了 ( L 1 L_1 L1​ ) 和 ( L 2 L_2 L2​ ) 正则化项**，控制叶节点数量和权重大小，使模型更具泛化能力。目标函数为：

Obj = ∑ i = 1 N L ( y i , y ^ i ) + ∑ m = 1 M Ω ( f m ) \text{Obj} = \sum_{i=1}^N L(y_i, \hat{y}_i) + \sum_{m=1}^M \Omega(f_m) Obj=i=1∑N​L(yi​,y^​i​)+m=1∑M​Ω(fm​)

#### 损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​)

损失函数 L ( y i , y ^ i ) L(y_i, \hat{y}_i) L(yi​,y^​i​) 测量每个样本的预测误差。例如，常用的损失函数有：

*   **均方误差 (MSE)**：用于回归问题，定义为 L ( y i , y ^ i ) = 1 2 ( y i − y ^ i ) 2 L(y_i, \hat{y}_i) = \frac{1}{2}(y_i - \hat{y}_i)^2 L(yi​,y^​i​)=21​(yi​−y^​i​)2。
*   **对数损失 (Log Loss)**：用于二分类问题。 L ( y , y ^ ) = − ( y ⋅ log ⁡ ( y ^ ) + ( 1 − y ) ⋅ log ⁡ ( 1 − y ^ ) ) L(y, \hat{y}) = - \left( y \cdot \log(\hat{y}) + (1 - y) \cdot \log(1 - \hat{y}) \right) L(y,y^​)=−(y⋅log(y^​)+(1−y)⋅log(1−y^​))

#### 正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​)

正则化项 Ω ( f m ) \Omega(f_m) Ω(fm​) 用于控制模型复杂度，包含 L1 和 L2 正则化：

Ω ( f m ) = γ T + 1 2 λ ∑ j = 1 T w j 2 + α ∑ j = 1 T ∣ w j ∣ \Omega(f_m) = \gamma T + \frac{1}{2} \lambda \sum_{j=1}^T w_j^2 + \alpha \sum_{j=1}^T |w_j| Ω(fm​)=γT+21​λj=1∑T​wj2​+αj=1∑T​∣wj​∣

其中：

*   T T T 是树的叶节点数目。
*   w j w_j wj​ 是第 j j j 个叶节点的权重。
*   γ \gamma γ 控制叶节点的数量，较大的 γ \gamma γ 倾向于减少叶节点数量，使模型更简单。
*   λ \lambda λ 是 L2 正则化系数，控制叶节点权重的平方和，有助于平滑叶节点的权重。
*   α \alpha α 是 L1 正则化系数，控制叶节点权重的绝对值之和，促使部分权重趋向于零，从而构建更稀疏的模型。

### 使用二阶导数信息，加速收敛

GBDT 只使用损失函数的一阶导数（负梯度）来更新模型，而 XGBoost 通过泰勒展开，将损失函数对模型输出进行二阶展开，使用**一阶导数（梯度）和二阶导数（Hessian）** 来**构建树**，优化效果更佳。**二阶导数带来更精确的梯度信息来改进模型的更新，使得模型能够更快地收敛**。目标函数的二阶近似为：  
Obj (m) ≈ ∑ i = 1 N [ g i f m ( x i ) + 1 2 h i f m ( x i ) 2 ] + Ω ( f m ) \text{Obj}^{(m)} \approx \sum_{i=1}^N \left[ g_i f_m(x_i) + \frac{1}{2} h_i f_m(x_i)^2 \right] + \Omega(f_m) Obj(m)≈i=1∑N​[gi​fm​(xi​)+21​hi​fm​(xi​)2]+Ω(fm​)

其中：

*   g i = ∂ L ( y i , y ^ i ) ∂ y ^ i g_i = \frac{\partial L(y_i, \hat{y}_i)}{\partial \hat{y}_i} gi​=∂y^​i​∂L(yi​,y^​i​)​ 是损失函数的一阶导数（梯度）。
*   h i = ∂ 2 L ( y i , y ^ i ) ∂ y ^ i 2 h_i = \frac{\partial^2 L(y_i, \hat{y}_i)}{\partial \hat{y}_i^2} hi​=∂y^​i2​∂2L(yi​,y^​i​)​ 是损失函数的二阶导数（Hessian）。

#### 一阶导数与二阶导数的区别

1.  一阶导数（梯度）：**表示损失函数的斜率**，指向使损失减少的方向，即当前点处的损失下降趋势。梯度**通常用于确定优化的方向**。
2.  二阶导数（Hessian）：**表示一阶导数的变化率**，反映了**损失曲面的曲率信息**。 Hessian 的大小可以**帮助判断步长的合适大小**，使得更新**更加精确**。

#### 二阶导数的优势

1.  更准确的步长控制：根据损失曲率调整步长，避免步长过大或过小。
2.  更快速的收敛：二阶导数的曲率信息能帮助模型更快接近最优解，减少迭代次数。
3.  更稳定的优化过程：使得模型在平坦或复杂的损失函数下依然能够有效地更新。

##### 1. 更准确的步长选择，避免过大或过小的更新

使用二阶导数信息可以调整步长，使得模型更新在合适的尺度上进行。步长过大会导致优化震荡或跳过最优解，而步长过小会导致优化缓慢。引入二阶导数可以：

*   自动缩小步长：在损失曲面曲率较大的地方，二阶导数值较大，步长会相应减小，避免更新过大。
*   自动增大步长：在曲率较小的地方，二阶导数值较小，步长会相应增大，使得优化更快速。

这一点**在非线性损失函数中尤其重要**，因为仅靠一阶导数的信息无法准确反映损失的局部曲率。

##### 2. 更快速的收敛

二阶导数提供了**额外的曲率信息**，优化过程能够更接近牛顿法的优化效果。**牛顿法是一种使用二阶导数进行快速收敛的方法**，在每次迭代中更新量为：  
![](https://i-blog.csdnimg.cn/direct/ae6ed8119c034c3d9fd5fcc3a37f453e.png)  
对于大多数损失函数，二阶导数的加入能显著加速收敛，减少所需的迭代次数。相较于仅使用梯度的信息，这种方法**能够更快地找到损失函数的最优解**，提升模型的训练效率。

##### 3. 更稳定的模型优化

在优化中，梯度可能会在平坦区域出现较小的值，导致步长极小，进展缓慢，而二阶导数能够平衡这一影响。在 XGBoost 中，使用一阶和二阶导数的信息构建目标函数，可以更好地处理一些曲面平坦或复杂的损失函数，保持更新的稳定性。

XGBoost 使用二阶泰勒展开将损失函数近似表示为一阶导数和二阶导数的组合。  
分裂增益的计算公式也包含二阶导数，这种基于二阶导数的增益计算能够更准确地评估分裂效果，从而选择使得损失减少最大的分裂点。

### 支持列采样和行采样，提升模型的泛化能力

XGBoost 支持列采样（Column Subsampling）和行采样（Row Subsampling），即在每次构建树时**随机选取**一部分**特征**和**样本**，而**不是使用全部特征 / 样本**，类似于随机森林的特征采样。具体来说 XGBoost 的采样方式包括：

1.  行采样：在每棵树的构建过程中**随机选择部分样本**。
2.  列采样：在每次分裂节点时，**随机选择部分特征**。

这种采样策略有助于降低模型的方差和过拟合风险，提高泛化能力。

是的，**XGBoost** 支持**列采样（Column Subsampling）**和**行采样（Row Subsampling）**，这两种采样方式能够提高模型的泛化能力，减少过拟合，同时提升训练速度。

#### 行采样（Row Subsampling）

*   **含义**：在训练每棵树时，XGBoost 会从训练数据集中**随机采样部分样本**（行）来训练该树，而不是使用全部样本。
*   **参数**：`subsample`
    *   **取值范围**：0 到 1。
    *   **作用**：`subsample=0.8` 表示在训练每棵树时，随机采样 80% 的训练数据。
    *   **优点**：通过减少训练数据量，加快了每棵树的训练速度，并且增加了模型的随机性，降低了过拟合风险。

#### 列采样（Column Subsampling）

*   **含义**：在训练每棵树或每个分裂节点时，XGBoost 会**随机采样部分特征**（列）来进行训练，而不是使用全部特征。
*   **参数**：XGBoost 提供了三种不同的列采样方式。
    *   **`colsample_bytree`**：在构建每棵树时，选择一部分特征进行训练。默认值是 1（即使用全部特征）。
    *   **`colsample_bylevel`**：在**每一层节点分裂**时，随机采样部分特征。
    *   **`colsample_bynode`**：在**每个节点进行分裂**时，随机采样部分特征。
*   **取值范围**：0 到 1。
    *   例如，`colsample_bytree=0.7` 表示在构建每棵树时，随机采样 70% 的特征。
*   **优点**：通过减少特征的使用，增加了模型的多样性，进一步降低了过拟合风险，特别是在高维数据集上效果显著。

#### 行采样与列采样的结合

XGBoost 支持将行采样和列采样结合使用，在训练过程中对样本和特征都进行随机采样，进一步提高模型的泛化能力。通过调节 `subsample` 和 `colsample_bytree`（或 `colsample_bylevel`、`colsample_bynode`）的值，找到一个在模型准确性和训练效率之间的平衡点。可以控制模型的复杂度和训练速度。

#### 优势总结

*   **降低过拟合**：通过引入随机性，行采样和列采样都能够减少模型对训练数据的依赖，防止模型过度拟合训练数据。
*   **加快训练速度**：采样减少了模型在训练每棵树时使用的数据量和特征数量，从而加快了模型训练过程，尤其是在大数据集上。
*   **增强模型的泛化能力**：适当的采样可以提高模型的泛化能力，提升在测试数据上的表现。

### 并行化处理，提升训练速度

传统的 GBDT 中，树的分裂点查找是顺序完成的，而 XGBoost 在此基础上进行了并行化优化。**XGBoost 的并行化**通过**特征分片**和**直方分裂**实现：

1.  **特征分片**：将特征划分为多个分片，每个分片分配给一个线程或进程独立计算增益，最终选择增益最大的分裂点。
2.  **直方分裂算法**：将连续特征值离散化成多个桶，通过桶的累计梯度和二阶导数和加速增益计算。直方分裂算法不仅减少计算量，还能够借助 GPU 进一步提升计算速度。

> 尽管最初版本的 XGBoost 并没有直方分裂算法这一功能。为了提升在大规模数据集上的训练效率，XGBoost 后来引入了基于直方图的分裂方法（直方分裂算法），与 LightGBM 类似。

#### 结合特征分片与直方分裂的并行化优势

*   **提高计算效率**：特征分片使得特征的增益计算可以并行执行，而直方分裂减少了增益计算的复杂度。两者结合可以显著加快分裂节点的速度。
*   **降低内存消耗**：直方分裂通过离散化特征值减少了内存占用，适合大规模数据集。
*   **适合大规模数据**：这种并行化方法使 XGBoost 在处理大规模数据时具有明显的速度优势，是 XGBoost 高效表现的关键因素之一。

#### LightGBM 和 XGBoost 中直方分裂的差异

虽然 XGBoost 和 LightGBM 都使用直方分裂算法，但两者在实现上存在一些差异：

1.  默认使用：**LightGBM 从一开始就使用直方分裂方法**，并将其作为默认的分裂方法。而在 **XGBoost** 中，直方分裂并不是默认方式，**用户可以选择是否启用**。
2.  特征分桶方式：LightGBM 使用了更高级的**互斥特征绑定**（Exclusive Feature Bundling, EFB）来进一步优化直方分裂的内存使用；XGBoost 则没有使用此技术。
3.  树生长策略：**LightGBM 使用叶子生长策略**（Leaf-wise Growth Strategy），增益计算用于决定叶节点的分裂，而 **XGBoost 使用层级生长策略**（Level-wise Growth Strategy），增益计算用于分裂同一层的所有节点。

### 支持缺失值处理和稀疏特征优化

XGBoost 提供了对缺失值和稀疏特征的优化处理。对于数据集中缺失的特征，XGBoost 通过如下方式处理：

1.  自动分裂方向：在构建树时，XGBoost **自动决定缺失值样本应归入左子树还是右子树，选择带来最高增益的方向**。
2.  稀疏特征支持：XGBoost 支持稀疏输入矩阵，这在缺失值较多的场景下大大减少了存储和计算的开销。

### 提供早停机制和学习率衰减，控制训练过程

XGBoost 支持早停机制（Early Stopping），即通过在验证集上监控模型的表现，当验证集性能不再提升时自动终止训练。这减少了不必要的计算开销，节省了时间。此外，XGBoost 支持学习率衰减（Shrinkage），在每一轮的更新中衰减当前树的权重，平滑模型，提高泛化性能：  
![](https://i-blog.csdnimg.cn/direct/25bddf597c114e81b9c8365f11201a24.png)

LightGBM 相较于 XGBoost 的优势
------------------------

以下是 LightGBM 和 XGBoost 在每个关键特性上的实现方式对比。每个步骤详细说明两者的具体实现差异，以便更好地理解它们的不同之处。

### 训练速度

*   **LightGBM**：
    
    *   **直方分裂算法**：LightGBM 使用直方分裂算法，将连续特征值划分为固定数量的桶（如 256 个），然后在这些桶上计算增益。这大幅减少了计算量，因为只需要在桶级别计算增益，而非对所有特征值逐一计算。
    *   **叶子生长策略**：LightGBM 使用叶子生长策略，每次优先分裂增益最大的叶节点。这使得树能够在更少的深度下达到更高的拟合效果，同时也减少了计算量。
    *   **多线程并行支持**：LightGBM 支持多线程并行计算，在特征分片和桶级别上进行分裂增益计算，充分利用 CPU 资源。
*   **XGBoost**：
    
    *   **直方分裂（后续版本引入）**：早期版本的 XGBoost 没有直方分裂算法，而是遍历每个可能的分裂点。后续版本引入了直方分裂算法，但不是默认的分裂方式。
    *   **层级生长策略**：XGBoost 使用层级生长策略，即在每一层同时分裂所有节点。这种方法会构建出更平衡的树，但相对需要更大的树深度，计算开销也较大。
    *   **多线程并行支持**：XGBoost 也支持多线程并行计算，但由于层级生长策略在分裂节点时存在更高的依赖性，在多线程的效率上通常低于 LightGBM。

**总结**：LightGBM 的直方分裂算法和叶子生长策略使其训练速度通常快于 XGBoost，尤其是在大规模数据上。

#### 内存效率

*   **LightGBM**：
    
    *   **互斥特征绑定（EFB）**：LightGBM 使用 EFB 技术，将一些互斥的稀疏特征捆绑在一起，减少特征维度并降低内存使用。EFB 可以显著减少特征存储需求，尤其适合高维稀疏数据。
    *   **原生支持稀疏特征**：LightGBM 对稀疏特征矩阵和缺失值有原生支持。在计算分裂增益时能够跳过缺失值，避免存储和计算的冗余。
*   **XGBoost**：
    
    *   **没有 EFB 支持**：XGBoost 没有互斥特征绑定技术，因此在处理稀疏高维特征时，内存使用更高。
    *   **稀疏矩阵支持（数据填充方式不同）**：XGBoost 通过填充值的方式处理稀疏特征，在内存使用上相对高于 LightGBM，但也能有效处理缺失数据。

**总结**：LightGBM 的 EFB 技术和稀疏特征原生支持使其在处理高维稀疏数据时更节省内存，而 XGBoost 缺乏这一优化。

### 类别特征支持

*   **LightGBM**：
    
    *   **原生类别特征支持**：LightGBM 允许用户直接指定类别特征。训练时无需将类别特征独热编码（One-Hot Encoding），而是通过增益计算自动选择最佳的类别组合分裂方式。这种方式不仅保留了类别特征的原始信息，还减少了内存和计算量。
*   **XGBoost**：
    
    *   **不支持原生类别特征**：XGBoost 不支持直接处理类别特征，必须对类别特征进行独热编码或标签编码。这导致数据维度增大，计算和内存开销增加。

**总结**：LightGBM 能原生处理类别特征，节省内存和提升速度，而 XGBoost 需要手动对类别特征进行编码。

### 扩展性和分布式训练支持

*   **LightGBM**：
    
    *   **分布式训练**：LightGBM 自带分布式支持，能够在多个节点上实现高效的分布式计算，适合在集群上处理超大数据集。
    *   **GPU 加速**：LightGBM 支持 GPU 加速，特别适用于大数据集。其 GPU 实现主要基于直方分裂算法，对高并发的 GPU 硬件优化良好。
*   **XGBoost**：
    
    *   **分布式训练**：XGBoost 也支持分布式训练，但在集群上的效率通常低于 LightGBM，因为其层级生长策略对分布式环境要求较高。
    *   **GPU 加速**：XGBoost 也支持 GPU 加速，GPU 加速在基于直方分裂的计算上表现出色。但在大数据集上，LightGBM 的 GPU 加速往往效率更高。

**总结**：在分布式训练上，LightGBM 对超大规模数据的支持更高效；GPU 加速在两者中均有支持，但 LightGBM 的表现通常更快。

### 早停机制和自动调参

*   **LightGBM**：
    
    *   **早停机制**：LightGBM 支持灵活的早停机制，能够在验证集上监控模型性能，若性能不再提升则提前停止训练。尤其在多线程和分布式训练时，LightGBM 的早停机制具有较好的效果。
    *   **自动调参**：LightGBM 支持对一些关键参数（如叶节点数量、分裂增益阈值等）的自动调节，用户可以通过参数控制训练的精度和速度，简化调参过程。
*   **XGBoost**：
    
    *   **早停机制**：XGBoost 也支持早停机制，用户可以通过验证集的性能表现来提前终止训练。其早停机制虽然有效，但在多线程环境下的表现通常不如 LightGBM 稳定。
    *   **自动调参**：XGBoost 没有自动调参机制，用户通常需要手动进行超参数调节，在调整分裂增益阈值等关键参数时更为繁琐。

**总结**：LightGBM 提供了更灵活的早停机制和自动调参功能，XGBoost 虽然也支持早停，但在自动调参上更依赖用户手动设置。

### 过拟合控制

*   **LightGBM**：
    
    *   **多种正则化参数**：LightGBM 通过设置最大深度、叶节点数、最小增益阈值等，细致控制模型的复杂度，防止模型过拟合。这些参数特别适合在叶子生长策略下防止模型的过拟合。
    *   **数据采样**：LightGBM 支持行采样和列采样，以降低模型的方差并增强泛化能力。
*   **XGBoost**：
    
    *   **正则化控制**：XGBoost 通过引入 (L_1) 和 ( L_2 ) 正则化项控制叶节点权重，防止过拟合。虽然在控制过拟合上有效，但层级生长策略下的正则化效果不如 LightGBM 灵活。
    *   **数据采样**：XGBoost 也支持行和列的随机采样，帮助控制模型的方差，但在设置上不如 LightGBM 直观。

**总结**：LightGBM 的正则化控制更加灵活，能够更好地控制过拟合，而 XGBoost 的层级生长策略对深度的控制不如 LightGBM。

#### 总结

<table><thead><tr><th>特性</th><th>LightGBM 优势</th><th>XGBoost 实现特点</th></tr></thead><tbody><tr><td><strong>训练速度</strong></td><td>直方分裂、叶子生长策略、多线程优化提升速度</td><td>引入直方分裂（非默认），层级生长策略，多线程效果不及 LightGBM</td></tr><tr><td><strong>内存效率</strong></td><td>互斥特征绑定和稀疏特征原生支持</td><td>没有 EFB，稀疏矩阵通过填充处理，内存效率低于 LightGBM</td></tr><tr><td><strong>类别特征支持</strong></td><td>原生支持类别特征，节省内存，提升速度</td><td>不支持原生类别特征，需独热编码，内存和计算量增加</td></tr><tr><td><strong>扩展性和分布式训练</strong></td><td>更高效的分布式支持和 GPU 加速</td><td>支持分布式和 GPU，但效率通常低于 LightGBM</td></tr><tr><td><strong>早停和自动调参</strong></td><td>灵活的早停机制，自动调参简化调参过程</td><td>早停效果稍弱，缺乏自动调参，需手动设置</td></tr><tr><td><strong>过拟合控制</strong></td><td>更细粒度的参数控制，有效防止叶子生长策略的过拟合</td><td>L1 和 L2 正则化控制权重，层级生长策略对深度的控制较差</td></tr></tbody></table>

总体而言，LightGBM 相较于 XGBoost 在大数据处理、类别特征支持、内存优化和训练速度方面具有明显优势，特别适合处理大规模、高维稀疏数据的应用。

![](https://i-blog.csdnimg.cn/direct/83f061e470ce4f819e6ead99771ec313.png)

聚类
--

### K-Means

K-Means 是一种经典的聚类算法，用于**将数据集划分为 K 个簇**，每个簇由其质心（簇中心）表示。算法的目标是**最小化簇内样本点到质心的平方距离之和**，从而使得同一个簇内的样本更加相似。

#### 工作原理

1.  **选择初始质心**：随机选择 K 个点作为初始质心。
2.  **分配样本到最近的质心**：将每个样本分配给距离最近的质心，形成 K 个簇。
3.  **更新质心**：重新计算每个簇的质心，即簇内所有样本的平均值。
4.  **重复步骤 2 和 3**，直到质心不再变化或达到最大迭代次数。

#### 特点

*   **优点**：简单易实现，计算速度快，适合大规模数据集。
*   **缺点**：对**初始质心敏感，容易陷入局部最优**；**K-Means 基于欧氏距离，通常只能处理球形或凸形簇**。

### K-Medoids

K-Medoids（也称为 **PAM**，Partitioning Around Medoids）是一种基于原型的聚类算法，与 K-Means 类似，但它**选择数据点本身作为质心**（称为 Medoid），**而不是质心的平均值。**

#### 工作原理

1.  **选择初始 Medoid**：**随机选择 K 个数据点作为初始 Medoid**。
2.  **分配样本到最近的 Medoid**：将每个样本分配给距离最近的 Medoid，形成 K 个簇。
3.  **更新 Medoid**：在每个簇内选择一个新的数据点，使得该点到簇内所有其他点的距离之和最小。
4.  **重复步骤 2 和 3**，直到 Medoid 不再变化或达到最大迭代次数。

> 更新 Medoid 如何做：
> 
> 1.  计算每个点的总距离：对于簇内的每个数据点 x i x_i xi​，计算该点到簇内所有其他点的距离之和；
> 2.  选择距离最小的点：找到使得距离之和最小的那个点作为新的 Medoid。
> 
> 计算量很大

#### 特点

*   **优点**：**对异常值不敏感**（因为选择实际数据点作为 Medoid），适合非球形簇。
*   **缺点**：计算复杂度高，不适合大规模数据集。

### Mini-Batch K-Means

Mini-Batch K-Means 是 K-Means 的一种扩展，旨在提高计算效率和速度。它通过在每次**迭代中使用小批量的随机样本来更新质心，而不是使用整个数据集**。

#### 工作原理

1.  **选择初始质心**：随机选择 K 个点作为初始质心。
2.  **抽取小批量数据**：从数据集中随机抽取一个小批量的数据点。
3.  **分配样本到最近的质心**：将小批量数据中的每个样本分配给距离最近的质心。
4.  **更新质心**：根据小批量数据更新质心，而不是全量数据。
5.  **重复步骤 2 到 4**，直到质心收敛或达到最大迭代次数。

#### 特点

*   **优点**：计算速度快，内存占用少，适合大规模数据集和在线学习场景。
*   **缺点**：相较于 K-Means 可能会损失一些精度，质心的更新不如全量数据集的更新精确。

### K-Means++（重要）

K-Means++ 是 **K-Means 的改进版本**，旨在通过**改进初始质心的选择**来提高聚类效果和算法的稳定性。它能有效**减少 K-Means 对初始质心的敏感性问题**。

#### 工作原理

1.  **选择第一个质心**：从数据集中随机**选择一个样本点**作为第一个质心。
2.  **选择下一个质心**：选择**距离现有质心最远的点作为下一个质心**，选择概率与当前最小距离成正比。
3.  **重复步骤 2**，直到选择出 K 个质心。
4.  按照 K-Means 算法的步骤进行聚类。

#### 特点

*   **优点**：初始质心选择更好，聚类效果更加稳定，收敛速度更快。
*   **缺点**：相比 K-Means 增加了一定的计算开销。

### 总结

*   **K-Means**：**随机选择 K 个点**作为初始质心。简单高效，适合大多数常见场景，但对初始质心敏感。
*   **K-Medoids**：**随机选择 K 个数据点**作为初始 Medoid。适合处理含有异常值或非球形分布的聚类问题，但计算复杂度较高。
*   **Mini-Batch K-Means**：**随机选择 K 个点**作为初始质心，**与标准 K-Means 相同**。适合大规模数据和在线学习，速度快，但精度较 K-Means 略有下降。
*   **K-Means++**：**质心不是一次选出来的，从数据集中随机选择一个样本点**作为第一个质心，之后**距离现有质心最远的点作为下一个质心**。改进了初始质心的选择，收敛速度更快，效果更稳定。

### K 的选值

在 **K-means 聚类**算法中，选择合适的 K 值（即簇的数量）是一个重要的步骤。以下是几种常用的选择 K 值的方法：

#### 1. 肘部法则（Elbow Method）

肘部法则是 K-means 中**最常用的方法之一**，用于通过**观察误差下降的速率**来选择最佳的 K 值。

*   计算不同 K 值下的 **SSE（Sum of Squared Error）** 或 **簇内误差平方和**。SSE 是每个数据点到其所属簇中心的距离平方的总和，反映了簇内的紧密度。
*   将 SSE 对应不同 K 值绘制成曲线，曲线会随着 K 的增加而逐渐下降。
*   曲线会出现一个 “**肘部” 拐点**，从此点开始，SSE 的减少幅度明显减小。这个拐点对应的 K 值通常被认为是最佳值，因为此时增加簇的数量已经无法显著降低误差。

**优点：**

*   简单直观，容易实施。

**局限：**

*   肘部位置有时不明显，可能会出现多个可能的拐点或不显著的拐点。

#### 2. 平均轮廓系数（Silhouette Score）

轮廓系数是一种度量聚类质量的方法，通过**评估数据点在簇内的紧密度和簇间的分离度**，来选择最佳的 K 值。

*   对于每个 K 值，计算每个数据点的轮廓系数。轮廓系数的值范围为 [-1, 1]，值越接近 1，说明聚类效果越好。
*   计算每个数据点的轮廓系数后，取其平均值，得到该 K 值下的平均轮廓系数。
*   **选择具有最高平均轮廓系数的 K 值**，此时簇内紧密度和簇间分离度达到最佳平衡。

**优点：**

*   不仅考虑簇内紧密度，还考虑簇间分离度，对聚类效果的评价更全面。

**局限：**

*   计算轮廓系数比肘部法则复杂，需要更多的计算资源，尤其在大数据集上。

#### 3. Gap Statistic（间隙统计量）

间隙统计量方法通过**将实际聚类结果与随机分布数据的聚类结果进行对比**，选择最佳的 K 值。

*   首先对原始数据进行 K-means 聚类，计算簇内误差平方和。
*   然后生成与原始数据相同维度的**随机数据**集，重复相同的聚类过程，并计算随机数据的簇内误差平方和。
*   计算原始数据的簇内误差和随机数据的差值，即 Gap 值。
*   Gap 值越大，说明聚类结构越显著。选择使 Gap 值最大或首次达到局部最大值的 K 值。

**优点：**

*   可以有效评估聚类结构是否显著，适用于各种数据分布。

**局限：**

*   计算量较大，尤其在数据集较大时，需要多次生成随机数据集并重复聚类。

#### 4. Davies-Bouldin 指数

Davies-Bouldin 指数用于**评估簇内的紧密度和簇间的分离度**，选择较小的 Davies-Bouldin 指数的 K 值。

*   对于每个 K 值，计算所有簇的平均距离（紧密度）以及簇之间的距离（分离度）。
*   Davies-Bouldin 指数越小，表示簇内紧密、簇间分离，聚类效果越好。
*   选择 Davies-Bouldin 指数最小的 K 值。

**优点：**

*   简单有效，适合较小的数据集。

**局限：**

*   对数据分布敏感，某些分布下可能不适用。

#### 5. 信息准则（如 BIC/AIC）

在一些统计方法中，可以使用**信息准则**来选择 K 值，尤其是结合高斯混合模型（GMM）时。

*   计算不同 K 值下的 AIC（Akaike 信息准则）或 BIC（贝叶斯信息准则）。
*   AIC 和 BIC 的值越小，模型的解释性越强。
*   选择最小 AIC 或 BIC 值对应的 K 值。

**优点：**

*   适用于高斯分布假设下的聚类模型（如 GMM）。

**局限：**

*   适用于较小的高斯混合数据，不适用于所有 K-means 场景。

#### 总结

*   **肘部法则**：最常用，适合快速估计 K 值。
*   **轮廓系数**：对聚类质量评估更全面，适合复杂数据集。
*   **Gap Statistic**：适合验证聚类是否显著。
*   **Davies-Bouldin 指数**：通过簇内紧密度和簇间分离度选择 K。
*   **AIC/BIC**：适合与高斯混合模型（GMM）结合使用。

每种方法有其优缺点，可以根据具体的应用场景和数据特点选择合适的 K 值选择方法。

### 高斯混合模型（GMM, Gaussian Mixture Model）

用于**聚类和概率密度估计**的模型，它假设**数据由多个高斯分布加权组合**混合而成。GMM 能够**比 K-Means 更灵活地表示数据，它允许每个簇具有不同的大小、形状和方向**。

#### 公式

p (x) = ∑ k = 1 K π k ⋅ N ( x ∣ μ k , Σ k ) p(x) = \sum_{k=1}^K \pi_k \cdot \mathcal{N}(x \mid \mu_k, \Sigma_k) p(x)=k=1∑K​πk​⋅N(x∣μk​,Σk​)  
其中：

*   **K K K**：簇的数量，即**高斯分布的数量**。
*   **π k \pi_k πk​**：第 k k k 个高斯分布的混合系数，表示**该簇占总数据的比例**，且 ∑ k = 1 K π k = 1 \sum_{k=1}^K \pi_k = 1 ∑k=1K​πk​=1。
*   **N ( x ∣ μ k , Σ k ) \mathcal{N}(x \mid \mu_k, \Sigma_k) N(x∣μk​,Σk​)**：第 k k k 个高斯分布，具有**均值 μ k \mu_k μk​** 和**协方差矩阵 Σ k \Sigma_k Σk​**。

> 该模型假设数据点 x x x 是从 K K K 个高斯分布的加权和中采样得到的，其中每个高斯分布的权重由 π k \pi_k πk​ 决定。

#### 优势

*   能够表示数据集中的**复杂分布**，包括**不同形状和大小的簇**。
*   每个簇由高斯分布表示，而**非简单的球形聚类**。
*   适合处理数据具有**重叠**或**不规则形状**的聚类问题。

### EM 算法（Expectation-Maximization Algorithm）

EM 算法是一种迭代优化算法，**GMM 的参数估计**通常**使用期望最大化（EM）算法**。它被广泛用于训练像 GMM 这样的概率模型。EM 算法包含两个主要步骤：期望步骤（E 步）和最大化步骤（M 步）。

#### 使用 EM 训练 GMM（进行参数估计）

##### EM 算法的步骤

1.  **初始化**：

*   随机初始化每个高斯分布的均值 μ k \mu_k μk​、协方差 Σ k \Sigma_k Σk​ 和混合系数 π k \pi_k πk​。
*   初始化可以通过随机选取数据点或使用 K-Means 聚类结果来设置初始值。

> 随机初始化模型参数（如 GMM 中的混合系数、均值和协方差矩阵）。

2.  **E 步（Expectation Step）**：

*   计算每个数据点属于每个高斯分布 (簇) 的后验概率(责任度)，表示数据点由每个分量生成的概率。
    
*   计算公式：  
    r i k = π k ⋅ N ( x i ∣ μ k , Σ k ) ∑ j = 1 K π j ⋅ N ( x i ∣ μ j , Σ j ) r_{ik} = \frac{\pi_k \cdot \mathcal{N}(x_i \mid \mu_k, \Sigma_k)}{\sum_{j=1}^K \pi_j \cdot \mathcal{N}(x_i \mid \mu_j, \Sigma_j)} rik​=∑j=1K​πj​⋅N(xi​∣μj​,Σj​)πk​⋅N(xi​∣μk​,Σk​)​
    
    其中 r i k r_{ik} rik​ 表示数据点 x i x_i xi​ 属于簇 k k k 的概率。
    

“责任度” 是**期望隐变量的条件概率，不是直接计算 “期望”**。

> 隐变量是模型中不可观测的变量（隐藏的结构或类别）。  
> 在 EM 算法中，隐变量通常是表示每个数据点由哪个潜在类别或簇生成的。

3.  **M 步（Maximization Step）**：

利用 E 步计算得到的隐变量期望值（责任度） r i k r_{ik} rik​ 来更新参数 π k \pi_k πk​、 μ k \mu_k μk​ 和 Σ k \Sigma_k Σk​。**最大化当前参数的似然函数**，更新模型的参数。这一步的目标是优化模型参数，使得当前模型对数据的拟合更好。

**(1). 更新混合系数 π k \pi_k πk​**

混合系数 π k \pi_k πk​ 表示簇 k k k 所占的比例，可以通过责任值的总和归一化来计算：

π k = ∑ i = 1 N r i k N \pi_k = \frac{\sum_{i=1}^N r_{ik}}{N} πk​=N∑i=1N​rik​​

其中：

*   N N N 是数据点的总数。
*   ∑ i = 1 N r i k \sum_{i=1}^N r_{ik} ∑i=1N​rik​ 表示簇 k k k 对所有数据点的**责任度总和**，即簇 k k k 中有效的数据点数量。

**(2). 更新均值 μ k \mu_k μk​**

簇 k k k 的均值 μ k \mu_k μk​ 更新为所有数据点 x i x_i xi​ 的加权平均值，权重为责任度 r i k r_{ik} rik​：

μ k = ∑ i = 1 N r i k ⋅ x i ∑ i = 1 N r i k \mu_k = \frac{\sum_{i=1}^N r_{ik} \cdot x_i}{\sum_{i=1}^N r_{ik}} μk​=∑i=1N​rik​∑i=1N​rik​⋅xi​​

这里：

*   r i k ⋅ x i r_{ik} \cdot x_i rik​⋅xi​ 表示数据点 x i x_i xi​ 对均值 μ k \mu_k μk​ 的贡献，按责任度加权。
*   分母 ∑ i = 1 N r i k \sum_{i=1}^N r_{ik} ∑i=1N​rik​ 是簇 k k k 中有效的数据点数量，确保均值为责任加权的结果。

**(3). 更新协方差矩阵 Σ k \Sigma_k Σk​**

协方差矩阵 Σ k \Sigma_k Σk​ 表示簇 k k k 的数据分布形状和大小。协方差矩阵更新为所有数据点的加权方差，其中权重为责任度 r i k r_{ik} rik​：

Σ k = ∑ i = 1 N r i k ⋅ ( x i − μ k ) ( x i − μ k ) T ∑ i = 1 N r i k \Sigma_k = \frac{\sum_{i=1}^N r_{ik} \cdot (x_i - \mu_k)(x_i - \mu_k)^T}{\sum_{i=1}^N r_{ik}} Σk​=∑i=1N​rik​∑i=1N​rik​⋅(xi​−μk​)(xi​−μk​)T​

这里：

*   ( x i − μ k ) ( x i − μ k ) T (x_i - \mu_k)(x_i - \mu_k)^T (xi​−μk​)(xi​−μk​)T 表示数据点 x i x_i xi​ 与均值 μ k \mu_k μk​ 的偏差。
*   r i k ⋅ ( x i − μ k ) ( x i − μ k ) T r_{ik} \cdot (x_i - \mu_k)(x_i - \mu_k)^T rik​⋅(xi​−μk​)(xi​−μk​)T 是数据点 x i x_i xi​ 对协方差的贡献，按责任度加权。
*   分母 ∑ i = 1 N r i k \sum_{i=1}^N r_{ik} ∑i=1N​rik​ 是簇 k k k 的有效数据点数量。

5.  **重复 E 步和 M 步**，直到参数收敛或达到最大迭代次数。

#### EM 算法的特点

*   **适用性广**：可用于解决许多存在隐变量或缺失数据的优化问题，如 GMM 训练、因子分析、HMM 等。
*   **收敛性**：EM 算法每次迭代都会使似然函数单调增加，但可能收敛到局部最优解。
*   **对初始值敏感**：不同的初始值可能导致不同的收敛结果。

#### GMM 和 EM 的关系

*   **GMM 是模型，EM 是优化算法**：GMM 是一种模型，用于表示数据的概率分布，而 EM 是一种优化算法，用于最大化 GMM 的似然函数。
*   **EM 训练 GMM**：通过 EM 算法，GMM 能够在给定数据的情况下找到最优参数，包括每个高斯分布的均值、协方差和混合系数。

### GMM 与 K-Means 的比较

<table><thead><tr><th><strong>比较维度</strong></th><th><strong>GMM</strong></th><th><strong>K-Means</strong></th></tr></thead><tbody><tr><td><strong>簇形状</strong></td><td>可以处理任意形状的簇，包括椭圆形和复杂形状的簇。</td><td>只能处理球形或凸形簇。</td></tr><tr><td><strong>簇分配</strong></td><td><strong>软聚类</strong>，输出数据点属于每个簇的概率。</td><td><strong>硬聚类</strong>，每个数据点只能分配给一个簇。</td></tr><tr><td><strong>参数估计</strong></td><td>使用 EM 算法进行参数估计，包含均值、协方差和混合系数。</td><td>通过欧氏距离最小化，找到质心并分配数据点。</td></tr><tr><td><strong>对初始值敏感</strong></td><td>对初始参数较为敏感，容易陷入局部最优解。</td><td>对初始质心敏感，初始值不当可能导致较差结果。</td></tr><tr><td><strong>计算复杂度</strong></td><td>计算协方差矩阵，复杂度较高。</td><td>计算欧氏距离，复杂度较低。</td></tr></tbody></table>

### 其他聚类算法

#### 层次聚类（Hierarchical Clustering）

层次聚类是一种构建层次结构的聚类算法，可以生成一棵聚类树（又称为树状图，dendrogram），并在不同层次的分组中展现数据的聚类结构。层次聚类可以分为两类方法：**凝聚式（自底向上）**和**分裂式（自顶向下）**。

##### 1. 凝聚式层次聚类（Agglomerative Hierarchical Clustering）

在凝聚式层次聚类中，每个数据点从一开始被当作一个单独的簇，不断将相近的簇合并，直到达到预定的簇数量或合并距离超出阈值。

**过程**：

*   初始化：每个数据点作为一个簇。
*   迭代：计算所有簇之间的距离，将距离最小的两个簇合并为一个簇。
*   重复上述步骤，直到只剩下一个簇或达到设定的停止条件。

**常用的距离度量方法**：

*   **单链接**：计算两个簇之间最近的点的距离。
*   **全链接**：计算两个簇之间最远的点的距离。
*   **平均链接**：计算两个簇之间所有点对距离的平均值。
*   **中心链接**：计算两个簇中心点之间的距离。

##### 2. 分裂式层次聚类（Divisive Hierarchical Clustering）

分裂式层次聚类从一个包含所有数据点的大簇开始，然后逐步将每个簇分裂为较小的簇，直到每个簇包含单个数据点或达到停止条件。

**过程**：

*   初始化：将所有数据点放入一个簇。
*   迭代：选择一个簇，将其分裂为两个子簇（通常基于聚类算法如 K-means）。
*   重复上述步骤，直到满足终止条件。

##### 优缺点

*   **优点**：层次聚类不需要预设簇的数量，并且生成的树状图可以帮助我们理解数据的层次结构。
*   **缺点**：计算复杂度高，尤其是对大数据集，时间和空间开销较大；不同的距离度量方法会影响聚类结果。

#### DBSCAN（Density-Based Spatial Clustering of Applications with Noise）

DBSCAN 是一种基于密度的聚类算法，它将数据点分为高密度区域的簇和低密度区域的噪声点。DBSCAN 可以发现任意形状的簇，并且能够自动检测噪声点。它适合用于空间分布不均匀的聚类任务。

##### 核心概念

1.  **核心点**（Core Point）：在给定半径 ϵ \epsilon ϵ 内包含至少 MinPts 个邻居的点。
2.  **边界点**（Border Point）：在 ϵ \epsilon ϵ 半径内邻居数小于 MinPts 的点，但至少和一个核心点邻接。
3.  **噪声点**（Noise Point）：既不是核心点也不是边界点的点，通常被视为孤立点或噪声。

##### 参数

*   **ϵ \epsilon ϵ**（半径）：用于确定邻域的半径。
*   **MinPts**：在 ϵ \epsilon ϵ 邻域内点的最小数量，用于定义核心点。

##### 工作流程

1.  **选择一个未访问的数据点**：
    *   如果该点是核心点，从该点开始扩展一个新簇，将它和其密度可达的点全部加入该簇。
    *   如果该点是边界点，则标记为边界点，并与已有簇的核心点连接。
    *   如果是噪声点，则将其标记为噪声，放弃该点。
2.  **扩展簇**：
    *   对于每个核心点，通过密度连接的方式，将所有密度可达的点加入同一簇。
3.  **迭代**：
    *   重复上述步骤，直到所有点都被访问过。

##### 特点

*   **密度可达**：如果一个点能够通过一系列的核心点连接到另一个点，则称这两个点密度可达。
*   **噪声检测**：DBSCAN 能够有效检测出数据中的噪声点。
*   **簇的任意形状**：DBSCAN 适合发现任意形状的簇，特别是非球形的簇结构。

##### 优缺点

*   **优点**：
    *   不需要预设簇的数量。
    *   能处理不同密度的簇，适合任意形状的聚类。
    *   能有效检测噪声点。
*   **缺点**：
    *   参数 ϵ \epsilon ϵ 和 MinPts 的选择较敏感。
    *   不适合检测簇密度差异较大的数据集。
    *   对高维数据表现较差，因为在高维空间很难定义合理的密度。

##### 参数选择

DBSCAN 中的参数选择对结果有较大影响，常用方法如下：

*   通过 K - 距离图（K-distance graph）选择 ϵ \epsilon ϵ：计算每个点到其 K 个最近邻的距离，然后对这些距离排序。当图中有明显拐点时，拐点的距离即为 ϵ \epsilon ϵ 的值。
*   MinPts 的选择：通常取 2 倍于数据的维度大小，例如在二维数据中可以取 MinPts = 4。  
    ![](https://i-blog.csdnimg.cn/direct/f6209f62136f46b7bb7d15abd81d6500.png)

降维方法概述
------

**降维**目的是将**高维**数据`映射到`**低维**空间中，同时**尽量保留数据的主要信息**。降维可以**减少数据冗余**、**降低计算复杂度**、**减轻过拟合**风险，并帮助我们更好地理解和可视化数据。降维方法主要分为**线性降维**和**非线性降维**两类。

线性降维方法
------

### 定义

线性降维方法假设数据可以通过**线性变换从高维空间映射到低维空间**。这类方法适用于**数据具有线性结构 / 线性分布**的情况。

### 特点

*   **线性变换**：通过线性变换（如矩阵乘法）来将高维数据映射到低维空间。
*   **全局结构**：关注数据的全局结构，试图在降维过程中保留整体几何和统计特性。
*   **计算简单**：计算复杂度低，结果具有良好的可解释性。
*   **局限性**：对具有复杂非线性结构的数据表现不佳。

### 常见方法

#### PCA（Principal Component Analysis，主成分分析）

##### 原理

PCA 是一种**无监督**的**线性降维方法**，目的是通过**寻找数据中方差最大的投影方向**，将数据从高维空间映射到一个低维空间。PCA 的基本思想是：**最大化数据在降维空间中的方差**，即使得降维后的数据尽可能地保留原始数据的信息。

##### 步骤

1.  **数据中心化**：将数据矩阵的每一列减去其均值，使数据均值为零。
2.  **计算协方差矩阵**：对于 n × p n \times p n×p 的数据矩阵 X X X，计算协方差矩阵 C = 1 n − 1 X T X C = \frac{1}{n-1} X^T X C=n−11​XTX。
3.  **特征值分解**：对协方差矩阵 C C C 进行特征值分解，得到特征值和对应的特征向量。特征值表示主成分的方差，特征向量表示主成分的方向。
4.  **选择主成分**：选择前 k k k 个最大特征值对应的特征向量，作为新的低维空间的基向量。
5.  **数据投影**：将原始数据投影到选定的主成分上，得到降维后的数据。

##### 降维后的数据

经过降维后：  
Y = X W Y = X W Y=XW

*   **X X X**：**原始数据矩阵**，包含 n n n 个样本和 p p p 个特征。
*   **W W W**：包含**前 k k k 个主要特征向量的矩阵**，这些特征向量对应于最大特征值，表示数据的主要方向。
*   **Y Y Y**：**降维后的数据矩阵**，表示将原始数据从 p p p 维空间投影到 k k k 维空间后的结果。

通过将 X X X 与 W W W 相乘，得到的 Y Y Y 可以保留数据的主要特征信息，同时减少维度，便于后续分析。

##### 优点

*   **最大化方差**：PCA 能找到数据方差最大的方向，并将数据投影到这些方向上，尽可能保留数据的主要信息。
*   **降维效果好，计算简单**：只涉及矩阵分解和简单的线性代数运算，计算效率高，同时保持了数据的主要结构。

##### 缺点

*   **无法处理非线性关系**：PCA 假设数据是线性分布的，无法处理非线性关系的数据。
*   **对离群点敏感**：PCA 使用的协方差矩阵会受到离群点的影响，因此对异常值敏感。
*   **解释性差**：主成分是线性组合，不总是容易解释为原始特征的物理含义。

##### 应用场景

*   **数据降维**：在高维数据中提取主要特征，例如图像压缩、降维后用于可视化。
*   **噪声消除**：通过保留方差较大的主成分，消除方差较小的噪声成分。
*   **特征提取**：在分类或回归问题中，通过 PCA 提取主要特征用于建模。

#### LDA（Linear Discriminant Analysis，线性判别分析）

##### 原理

LDA 是一种**有监督**的**线性降维方法**，目的是通过一个线性变换，**寻找一个最佳的投影方向**，使得变换后的**数据集类内差异最小，类间差异最大**。

> 在对比学习（Contrastive Learning）中，模型尝试**最大化**同类样本的相似性，同时**最小化**不同类样本之间的相似性。

##### 步骤

*   **计算类内散布矩阵 S W S_W SW​**：**反映同一类数据的分散程度**，类内散布矩阵的定义为各类别协方差矩阵的加权和：
    
    S W = ∑ i = 1 c S i = ∑ i = 1 c ∑ x ∈ C i ( x − μ i ) ( x − μ i ) T S_W = \sum_{i=1}^c S_i = \sum_{i=1}^c \sum_{x \in C_i} (x - \mu_i)(x - \mu_i)^T SW​=i=1∑c​Si​=i=1∑c​x∈Ci​∑​(x−μi​)(x−μi​)T
    
    其中， c c c 为类别数， μ i \mu_i μi​为第 i i i 类的均值向量。
    
*   **计算类间散布矩阵 S B S_B SB​**：**反映不同类别之间的分散程度**，类间散布矩阵的定义为各类别均值向量与总体均值向量的协方差矩阵：
    
    S B = ∑ i = 1 c n i ( μ i − μ ) ( μ i − μ ) T S_B = \sum_{i=1}^c n_i (\mu_i - \mu)(\mu_i - \mu)^T SB​=i=1∑c​ni​(μi​−μ)(μi​−μ)T
    
    其中， n i n_i ni​为第 i i i 类的样本数目， μ \mu μ为所有样本的均值向量。
    
*   **求解广义特征值问题**：通过**求解 S W − 1 S B S_W^{-1} S_B SW−1​SB​**的**特征值和特征向量**来找到最佳的投影方向。
    
*   **选择投影方向**：选择前 k k k 个特征值对应的特征向量，作为新的低维空间的基向量。
    
*   **数据投影**：将原始数据投影到这些基向量上，得到降维后的数据。
    

##### 降维后的数据

经过降维后：  
Y = X W Y = X W Y=XW

*   **X X X**：**原始数据矩阵**，包含 n n n 个样本和 p p p 个特征。
*   **W W W**：包含**前 k k k 个主要特征向量的矩阵**，这些特征向量对应于最大特征值，表示数据的主要方向。
*   **Y Y Y**：**降维后的数据矩阵**，表示将原始数据从 p p p 维空间投影到 k k k 维空间后的结果。

通过将 X X X 与 W W W 相乘，得到的 Y Y Y 可以保留数据的主要特征信息，同时减少维度，便于后续分析。

##### 优点

*   **区分性强**：LDA 利用类别信息，能够有效找到最有利于区分类别的投影方向。
*   **降维与分类结合**：LDA 同时实现了降维和分类，适合用于分类任务中的特征提取。

##### 缺点

*   **对非线性数据效果较差**：LDA 假设数据类别之间是线性可分的，对非线性数据效果较差。
*   **需要类别标签对类别分布敏感**：需要类别标签，类别不均衡时效果不佳，LDA 假设各类别的协方差矩阵相同，若类别分布差异较大，效果可能较差。

> 处理类别不均衡的技巧：
> 
> 1.  类权重调整：可以通过为**少数类别赋予更高的权重**，使 LDA 在投影时更多地考虑少数类别的分布。权重调整可以让模型对少数类别的数据给予更多的关注，减少类别不平衡的影响。
> 2.  重采样：在进行 LDA 之前，可以通过**欠采样多数类**或过**采样少数类**的方式来平衡类别分布。这样可以使模型在降维时更加均衡地考虑各个类别的特征。

> 过采样（Oversampling）少数类：通过**复制少数类样本**，增加少数类样本的数量，使得少数类与多数类样本数量相当。常见的方法有 SMOTE（Synthetic Minority Over-sampling Technique），它通过生成少数类样本的合成数据来平衡数据集。  
> 欠采样（Undersampling）多数类：**减少多数类样本数量**，使其与少数类样本数量接近。虽然会丢失部分多数类数据，但能防止多数类对降维结果的主导。

##### 应用场景

*   **分类任务中的降维**：在有标签数据中，用于降维和分类建模，例如人脸识别、文本分类等。
*   **小样本问题**：在样本较少而特征较多的分类问题中，LDA 可以减少维度，缓解过拟合问题。

#### SVD（Singular Value Decomposition，奇异值分解）——LORA 使用

##### 原理

SVD 是一种**矩阵分解技术**，它将一个矩阵分解为**三个矩阵的乘积**：

1.  **左奇异矩阵**
2.  **对角矩阵**
3.  **右奇异矩阵**

> SVD 是一种广义的矩阵分解方法，应用广泛，特别是在降维、数据压缩和矩阵填充 (如推荐系统) 中。SVD 在数学上等价于 PCA，但应用更加灵活

> ![](https://i-blog.csdnimg.cn/direct/67d909293a624d9d8d8e2c7aa9152b91.png)

##### 步骤

实现步骤如下：

*   **矩阵分解**：对**数据矩阵进行奇异值分解，得到 U、Σ 和 V 矩阵**。对于任意矩阵 X ∈ R m × n X \in \mathbb{R}^{m \times n} X∈Rm×n，SVD 将其分解为三个矩阵的乘积：  
    X = U Σ V T X= U \Sigma V^T X=UΣVT  
    其中：
    
    *   U U U 是 m × m m \times m m×m 的正交矩阵，称为左奇异向量矩阵。
    *   Σ \Sigma Σ 是 m × n m \times n m×n 的对角矩阵，对角元素为**奇异值**，按从大到小排列。
    *   V V V 是 n × n n \times n n×n 的正交矩阵，称为右奇异向量矩阵。
*   **奇异值与奇异向量**：**计算奇异值及对应的奇异向量。**
    
    *   奇异值是矩阵 X X X 的特征值，可以反映矩阵的固有性质。
    *   左奇异向量和右奇异向量分别是矩阵 X X T XX^T XXT 和 X T X X^T X XTX 的特征向量。
*   **低秩近似**：**选择前 k k k 个最大的奇异值及其对应的左右奇异向量，数据投影**，构造一个低秩矩阵来近似原矩阵，实现降维和数据压缩。
    

##### 降维后的数据

设原始数据矩阵为 X X X，它经过 SVD 分解为：  
X = U Σ V T X = U \Sigma V^T X=UΣVT  
在降维过程中，我们只保留前 k k k 个奇异值和相应的奇异向量，得到一个低秩近似表示。这时，我们可以表示降维后的数据矩阵为：  
Y = X W Y = X W Y=XW  
其中：

*   Y Y Y 是降维后的数据矩阵，大小为 n × k n \times k n×k。
*   W W W 是投影矩阵，**由 V V V 的前 k k k 列组成**，大小为 p × k p \times k p×k。

在这个表达式中， W = V k W = V_k W=Vk​，表示将原始数据 X X X 投影到由前 k k k 个右奇异向量构成的空间中。因此， Y = X W Y = X W Y=XW 等价于 Y = U k Σ k Y = U_k \Sigma_k Y=Uk​Σk​，实现了降维，同时保留了数据的主要信息。

##### 各矩阵含义

> 选择 V V V 的前 k k k 列来构造降维的投影矩阵 W W W，即 W = V k W = V_k W=Vk​。原因如下：
> 
> *   U U U：描述**样本的投影坐标**，表明在主成分方向上每个样本的投影。
> *   Σ \Sigma Σ：表示**奇异值**，反映不同方向的**重要性**和数据的伸缩量。
> *   V V V：描述**特征的主方向**，用于找到数据中最重要的特征方向。

##### 优点

*   **高效处理稀疏矩阵，适合大规模矩阵，保留主要结构信息**：SVD 能高效处理稀疏矩阵，特别适合在推荐系统中对评分矩阵进行降维。 能够提取数据中的主要模式和结构，减少噪声和冗余。

##### 缺点

*   **计算复杂度高**：对于大规模数据集，SVD 的分解过程计算复杂度较高。
*   **对噪声敏感**：奇异值分解容易受数据中的噪声影响，尤其是在高噪声数据中。
*   **局限性**：无法处理非线性关系。

##### 应用场景

*   **推荐系统**：在推荐系统中，SVD 用于分解用户 - 物品评分矩阵，找到潜在的关联模式。
*   **图像处理**：在图像压缩中，SVD 被用于提取图像中的主要特征，从而减少图像数据量。
*   **文本处理**：在自然语言处理中的词语共现矩阵或词向量的降维中，SVD 用于提取主要的语义信息。

#### 比较总结

<table><thead><tr><th><strong>方法</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>PCA</strong></td><td><strong>无监督</strong>降维方式，通过线性变换，<strong>寻找方差最大的方向作为主成分</strong>。</td><td>最大化方差，提取主要特征，计算简单。</td><td><strong>只捕捉线性关系</strong>，对离群点敏感，解释性差。</td><td>数据降维、噪声消除、特征提取、图像压缩。</td></tr><tr><td><strong>LDA</strong></td><td><strong>有监督</strong>降维方式，<strong>最大化类间方差，最小化类间方差</strong>与类内方差的比值，找到区分类别的投影方向。</td><td>结合降维与分类，区分性强，适合分类任务。</td><td>假设线性可分，<strong>对非线性数据效果较差</strong>，需要类别标签，<strong>对类别分布敏感</strong>。</td><td>分类任务中的降维，人脸识别、文本分类等。</td></tr><tr><td><strong>SVD</strong></td><td><strong>无监督</strong>降维方式，将<strong>矩阵分解为三个矩阵的乘积</strong>，提取矩阵中的主要模式和信息。</td><td><strong>适合处理稀疏矩阵</strong>，保留主要结构信息，数学基础坚实。</td><td>计算复杂度高，对噪声敏感。</td><td>推荐系统、<strong>图像处理</strong>、文本处理中的降维。</td></tr></tbody></table>

选择哪种方法取决于数据的特性和具体任务。如果是**无标签数据降维，可以使用 PCA 或 SVD**；如果是**有标签的分类问题，可以使用 LDA**。

*   PCA：主要用于无监督的降维，目标是最大化数据的方差，保留数据的主要信息。适用于数据的初步分析和可视化。
*   LDA：主要用于有监督的降维，目标是最大化类别分离度。适用于分类问题中的特征提取和降维。
*   SVD：广泛应用于各种数据处理任务，特别是矩阵分解和数据压缩。适用于降维、矩阵填充和数据压缩等任务。它在数学上等价于 PCA，但没有特别针对数据方差或类别分离度的优化目标。

非线性降维方法
-------

### 总结：不同核方法的核函数选择策略

核函数参考：[万字长文解读机器学习——感知机、MLP、SVM](https://lichuachua.blog.csdn.net/article/details/142449632)

<table><thead><tr><th><strong>方法</strong></th><th><strong>常用核函数</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>SVM</strong></td><td>线性核、RBF 核、多项式核、Sigmoid 核</td><td>- 线性核：高维稀疏数据（如文本分类）。<br>- RBF 核：非线性分类问题，复杂模式识别（如图像分类）。<br>- 多项式核：低维数据，类别边界呈现多项式关系。<br>- Sigmoid 核：神经网络式问题。</td></tr><tr><td><strong>Kernel PCA</strong></td><td>RBF 核、多项式核、线性核</td><td>- RBF 核：非线性降维，保留复杂的非线性模式（如图像处理、模式识别）。<br>- 多项式核：数据间呈现多项式关系的降维任务。<br>- 线性核：线性降维问题，数据结构简单。</td></tr><tr><td><strong>NDA</strong></td><td>RBF 核、多项式核、线性核</td><td>- RBF 核：非线性分类任务，复杂类别关系（如手写体识别）。<br>- 多项式核：类别间多项式关系的分类问题。<br>- 线性核：线性可分的分类任务。</td></tr></tbody></table>

*   对于**非线性数据**，**低维数据**，**高斯核 / RBF 核** 是最通用且常用的选择，能够有效处理复杂模式的分类、降维等任务。
*   如果**低维数据**，数据**类别**间存在明显的**多项式模式**或关系，可以选择**多项式核**。
*   对于**线性数据**或高维稀疏数据，**线性核**计算简单高效，通常是最佳选择。

### 定义

非线性降维是指数据分布在高维空间中的某个非线性流形上，**无法通过简单的线性变换**，**将高维数据映射到低维空间**，从而需要**通过非线性变换将高维数据映射到低维空间**。这些方法适用于数据结构复杂、无法通过线性变换良好表示的情况。

### 特点

*   **非线性变换**：使用非线性函数（如核函数、神经网络等）将数据映射到低维空间。
*   **局部结构**：能够捕捉数据的局部非线性结构，也可以兼顾全局结构。
*   **灵活性**：适用于具有复杂、非线性分布的数据，能够揭示数据的潜在低维流形结构。
*   **计算复杂**：计算复杂度较高，结果的可解释性较差。

### 常见方法

#### Kernel PCA（核主成分分析, Kernel Principal Component Analysis）

##### 原理

Kernel PCA 是主成分分析（PCA）的非线性扩展，**使用核函数将数据映射到高维特征空间**，在**高维空间中进行线性 PCA 操作**，捕捉数据中的**非线性结构**，**再将结果映射回原始空间**。

##### 步骤

![](https://i-blog.csdnimg.cn/direct/ac04ffcbbcef4f239e76b71f72fc6210.png)

> ##### 优点
> 
> *   **处理非线性数据**：通过核函数，Kernel PCA 能够处理线性不可分的数据，捕捉复杂的非线性结构。
> *   **灵活性强**：可以通过选择不同的核函数处理不同的数据分布和模式。
> 
> ##### 缺点
> 
> *   **结果难以解释**：由于在高维特征空间中进行操作，降维后的结果难以映射回原始空间进行解释。
> *   **计算复杂度高**：核矩阵的计算复杂度较高，特别是对于大规模数据集。
> 
> ##### 应用场景
> 
> *   图像处理、模式识别中的非线性降维。
> *   特征提取与数据可视化，特别适合具有复杂非线性结构的数据。

#### NDA（Nonlinear Discriminant Analysis，非线性判别分析）

##### 原理

NDA 是**线性判别分析（LDA）**的核函数扩展，适用于**分类任务中的降维**。**通过核函数将数据非线性映射到高维特征空间中**。在高维空间中执行类似于 LDA 的操作，找到能够**最大化类别间差异**的方向。**显式地将结果映射回原始空间。**

##### 步骤

![](https://i-blog.csdnimg.cn/direct/60f3d78cbb474ddaaf1955085f110ae0.png)

> ##### 优点：
> 
> *   **适合非线性分类问题**：通过核函数的作用，NDA 能够处理线性不可分的分类任务。
> *   **分类效果好**：NDA 结合了核函数和判别分析的优点，能够有效区分类别。
> 
> ##### 缺点
> 
> *   **依赖标签信息**：NDA 是有监督的降维方法，需要类别标签进行计算。
> *   **计算复杂**：计算核矩阵和类内、类间散布矩阵的过程相对复杂，尤其在高维数据中。
> 
> ##### 应用场景
> 
> *   在分类任务中用于降维和特征提取，如人脸识别、文本分类等。

*   适合需要同时进行降维和分类的应用场景。

#### T-SNE（t-Distributed Stochastic Neighbor Embedding，t 分布随机邻域嵌入）

##### 原理

T-SNE 是一种用于高维数据**非线性降维**和可视化的技术，特别适合处理高维数据中的局部结构。通过在**高维和低维空间中分别计算点对的相似度**，然后**最小化两个分布之间的差异，使相似数据点在低维空间中靠近**。

> T-SNE 的目标是将高维数据点嵌入到低维空间中，使得在**高维空间中彼此接近的数据点**在**低维空间中仍然保持接近**，而那些在高维空间中远离的数据点在低维空间中也保持远离。

##### 步骤

1.  **高维空间中的相似性计算**：在高维空间中，通过**高斯分布**计算每对数据点之间的相似性，得到条件概率 P i j P_{ij} Pij​ 表示点 x i x_i xi​ 和 x j x_j xj​ 之间的相似性。
    
2.  **低维空间中的相似性计算**：在低维空间中，使用 **t 分布**计算数据点之间的相似性，得到 Q i j Q_{ij} Qij​，表示低维空间中的相似性。
    
3.  **最小化 KL 散度**：通过最小化高维和低维空间中相似性概率分布之间的 KL 散度，确保在低维空间中保持高维数据的局部结构。
    

> ![](https://i-blog.csdnimg.cn/direct/83f9a1bd1ca94765a2613040e2813d60.png)  
> ![](https://i-blog.csdnimg.cn/direct/c2a2e390af30418481194d76463b1c2e.png)  
> ![](https://i-blog.csdnimg.cn/direct/cd4cea223b1f4c59ba7de96c77663b26.png)  
> **如何找到降维后的低维空间？**
> 
> *   **初始化**：从高维空间的原始数据中开始，通过**随机初始化来得到初步**的低维坐标 (y_i)。
> *   **高维与低维空间相似度计算**：在高维空间中使用高斯分布定义相似度，在低维空间中使用 t 分布定义相似度。
> *   **优化**：通过最小化高维和低维空间中相似度分布的差异（KL 散度），使用梯度下降不断优化低维坐标。
> *   **找到低维空间**：经过优化后，t-SNE 输出的低维嵌入 (y_i) 保留了高维数据的局部结构。

> ##### 优点
> 
> *   **局部结构保留良好**：t-SNE 强调保持高维数据中的局部结构，非常适合数据的可视化。
> *   **适合复杂数据集**：t-SNE 对于复杂的非线性数据表现良好，尤其适用于图像、文本等高维数据。

> ##### 缺点
> 
> *   **全局结构可能丢失**：t-SNE 主要关注局部结构，可能忽略全局数据的分布。
> *   **计算复杂度高**：t-SNE 的时间复杂度较高，尤其在大规模数据集上。
> *   **结果不稳定**：t-SNE 对参数（如 perplexity）敏感，不同初始条件可能会得到不同的结果。

> ##### 应用场景
> 
> *   高维数据的可视化，如图像、基因表达数据、文本嵌入等。
> *   聚类结果的展示和分析，用于理解复杂数据集的内部结构。

##### Autoencoder（自编码器）

##### 原理

详细介绍参考：[万字长文解读深度学习——AE、VAE](https://lichuachua.blog.csdn.net/article/details/143067237)

自编码器是一种基于**神经网络**的非线性降维方法，通过**压缩和重构**数据的方式实现降维。自编码器由两个部分组成：**编码器**和**解码器**。编码器将数据压缩到低维空间，而解码器则试图从低维表示中重构原始数据。通过最小化重构误差，自编码器能够学习到数据的低维表示。

##### 结构

1.  **编码器**：编码器部分是一个神经网络，输入数据经过编码器后被压缩到一个低维的隐空间（瓶颈层），这个隐空间表示就是数据的低维表示。
    
2.  **解码器**：解码器是另一个神经网络，它从隐空间的低维表示中尝试重构出原始的高维数据。
    
3.  **训练**：通过最小化输入数据与解码器输出数据之间的重构误差（如均方误差），自编码器可以学习到数据的低维表示。
    

> ##### 优点
> 
> *   **灵活性强**：自编码器可以处理复杂的非线性数据，并且可以适应各种数据类型（如图像、文本等）。
> *   **扩展性好**：自编码器可以通过增加网络层数和神经元数量来处理复杂的高维数据，具有很强的扩展性。

> ##### 缺点
> 
> *   **需要大量数据训练**：自编码器需要大量训练数据，并且训练过程较慢。
> *   **可能过拟合**：如果模型设计不当，自编码器可能会过拟合训练数据，导致泛化能力下降。
> *   **解释性差**：自编码器学到的低维表示不易解释，其隐层的表示可能难以理解和直观解释。

> ##### 应用场景
> 
> *   数据降维和特征提取，特别是在图像数据中的特征表示。
> *   图像去噪、异常检测，通过重构误差发现异常样本。
> *   用于生成模型（如变分自编码器，VAE）和数据生成任务。

#### 对比总结

<table><thead><tr><th><strong>方法</strong></th><th><strong>原理</strong></th><th><strong>目标</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td><strong>Kernel PCA</strong></td><td><strong>将数据映射到高维空间</strong>，通过核函数进行 PCA 来捕捉非线性特征</td><td><strong>核函数，非线性降维</strong></td><td>处理非线性数据，灵活性强</td><td>结果难解释，计算复杂度高</td><td>图像处理、模式识别、特征提取</td></tr><tr><td><strong>NDA</strong></td><td><strong>核函数与线性判别分析结合</strong>，在高维空间中进行判别分析</td><td><strong>核函数，分类任务中的非线性降维</strong></td><td>适合非线性分类，结合核函数和判别分析的优点</td><td>依赖标签信息，计算复杂度高</td><td>人脸识别、文本分类、降维和分类结合任务</td></tr><tr><td><strong>t-SNE</strong></td><td><strong>通过最小化 KL 散度</strong>来保持高维空间中的局部相似性关系</td><td><strong>数据可视化，非线性降维</strong></td><td><strong>局部结构保留好</strong>，适合复杂数据的可视化</td><td>全局结构丢失，计算复杂度高，结果不稳定</td><td>数据可视化，基因表达分析，图像和文本可视化</td></tr><tr><td><strong>自编码器</strong></td><td><strong>神经网络</strong>通过压缩和解压数据进行自监督学习，学习数据的低维表示</td><td>非线性降维，<strong>数据重构</strong></td><td>灵活性强，适合处理多种数据类型，能够学习复杂的非线性关系</td><td>需要大量数据训练，可能过拟合，结果解释性差</td><td>图像处理、去噪、异常检测，生成模型（VAE）</td></tr></tbody></table>

*   **Kernel PCA** 和 **NDA** 通过核函数扩展经典的线性降维和分类方法，能够处理非线性数据。
*   **t-SNE** 是一种专注于保持局部结构的降维方法，主要用于数据的可视化。
*   **自编码器** 则通过神经网络学习数据的低维表示，能够处理复杂的非线性关系，适合各种类型的数据。

总结
--

*   **线性降维方法**：适用于数据可以通过线性变换表示的情况，计算简单、可解释性强，但无法处理复杂的非线性结构。
*   **非线性降维方法**：适用于数据结构复杂的情况，能够捕捉数据中的非线性关系，但计算复杂度高，结果难以解释。

选择合适的降维方法取决于数据的特点和应用场景。对于具有简单线性关系的数据，线性降维方法通常更有效；对于具有复杂非线性结构的数据，非线性降维方法能够更好地揭示数据的潜在结构。

![](https://i-blog.csdnimg.cn/direct/c79d63a6867c4394bfae7709c2925121.png)